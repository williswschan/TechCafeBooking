<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="{{ csrf_token or '' }}">
    <title>TechCafe Booking Portal</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Socket.IO for real-time updates -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    
    <!-- External CSS Files -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/main.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/time-slots.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/modals.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/footer.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='css/responsive.css') }}">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-calendar-check"></i> TechCafe Booking Portal</h1>
            <p>Book your preferred time slot for today and upcoming days</p>
            <button id="kioskBtn" class="kiosk-btn" onclick="toggleKioskMode()">
                <i class="fas fa-desktop"></i>
                <span>Kiosk</span>
            </button>
            <button id="adminBtn" class="admin-btn" onclick="showAdminModal()">
                <i class="fas fa-user-shield"></i>
                <span>Admin</span>
            </button>
        </div>

        <!-- Scrollable Content Area -->
        <div class="scrollable-content">
            <div class="date-selector">
                <div class="date-tabs">
                    {% for date in dates %}
                    <div class="date-tab {% if loop.first %}active{% endif %}" 
                         data-date="{{ date.date }}" 
                         onclick="selectDate('{{ date.date }}', this)">
                        <div>{{ date.display.split('<br>')[0] if date.display else date.date }}</div>
                        <div style="font-size: 0.8rem; opacity: 0.8;">{{ date.display.split('<br>')[1] if date.display else '' }}</div>
                    </div>
                    {% endfor %}
                </div>
            </div>

            <div class="booking-grid">
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div>Loading bookings...</div>
            </div>
            <div id="timeSlots">
                <!-- Morning Section (09:00-12:00) -->
                <div class="time-section">
                    <div class="section-header">
                        <div class="section-divider"></div>
                        <div class="section-title">
                            <i class="fas fa-sun"></i> Morning Slots (09:00 - 12:00)
                        </div>
                    </div>
                    <div class="time-slots" id="morningSlots">
                        {% for slot in morning_slots %}
                        <div class="time-slot available" 
                             data-time="{{ slot }}">
                            <div class="time-text">{{ slot }}</div>
                            <div class="booked-text" style="display: none;">Available</div>
                        </div>
                        {% endfor %}
                    </div>
                </div>

                <!-- Lunch Break -->
                <div class="lunch-break">
                    <i class="fas fa-utensils"></i>
                    <div class="lunch-break-text">Lunch Break (12:00 - 14:00)</div>
                </div>

                <!-- Afternoon Section (14:00-18:00) -->
                <div class="time-section">
                    <div class="section-header">
                        <div class="section-divider"></div>
                        <div class="section-title">
                            <i class="fas fa-moon"></i> Afternoon Slots (14:00 - 18:00)
                        </div>
                    </div>
                    <div class="time-slots" id="afternoonSlots">
                        {% for slot in afternoon_slots %}
                        <div class="time-slot available" 
                             data-time="{{ slot }}">
                            <div class="time-text">{{ slot }}</div>
                            <div class="booked-text" style="display: none;">Available</div>
                        </div>
                        {% endfor %}
                    </div>
                </div>
            </div>
            </div> <!-- End scrollable-content -->
            
            <!-- Red Footer Section -->
            <div class="footer-section">
                <div class="footer-content">
                    <div class="footer-scroll-text">
                        <small>Connecting Market East & West | AI-Powered Booking Solution</small>
                    </div>
                </div>
            </div>
            
        </div>
    </div>

    <!-- Booking Modal -->
    <div id="bookingModal" class="modal">
        <div class="modal-content">
            <h3><i class="fas fa-user-plus"></i> Book Your Slot</h3>
            <p class="privacy-notice"><strong>⚠️ Your name will be shown publicly. Leave empty for privacy.</strong></p>
            <div class="typeahead-container">
                <input type="text" id="usernameInput" placeholder="Enter your name (optional)" maxlength="50" autocomplete="off">
                <div id="typeaheadDropdown" class="typeahead-dropdown"></div>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-primary" onclick="confirmBooking()">Confirm Booking</button>
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
            </div>
            <div class="clear-saved-info">
                <button class="btn btn-clear" onclick="clearSavedUsername()">
                    <i class="fas fa-trash-alt"></i> Clear Saved Name
                </button>
            </div>
        </div>
    </div>

    <!-- Admin Management Modal -->
    <div id="adminManagementModal" class="modal">
        <div class="modal-content">
            <h3><i class="fas fa-tools"></i> IT Support - Booking Management</h3>
            <p id="adminBookingInfo">Booking: <span id="adminBookingUser"></span> - <span id="adminBookingDateTime"></span><br><br>What action would you like to take?<br><br></p>
            <div class="modal-buttons admin-buttons">
                <button class="btn btn-success" onclick="showAdminCaseCompletedConfirmation()" title="IT support successfully resolved the user's issue">
                    <i class="fas fa-check-circle"></i> Case Completed - Free Slot
                </button>
                <button class="btn btn-danger" onclick="showAdminCancelConfirmation()" title="Remove this booking (user no-show, etc.)">
                    <i class="fas fa-times-circle"></i> Cancel Booking
                </button>
                <button class="btn btn-secondary" onclick="closeModal()" title="Close without making changes">
                    <i class="fas fa-times"></i> Close
                </button>
            </div>
        </div>
    </div>

    <!-- Regular Cancel Modal (for non-admin users) -->
    <div id="cancelModal" class="modal">
        <div class="modal-content">
            <h3><i class="fas fa-user-times"></i> Cancel Booking</h3>
            <p>Are you sure you want to cancel this booking?<br><br></p>
            <div class="modal-buttons">
                <button class="btn btn-danger" onclick="confirmCancellation()">Yes, Cancel</button>
                <button class="btn btn-secondary" onclick="closeModal()">No, Keep Booking</button>
            </div>
        </div>
    </div>

    <!-- Admin Cancel Confirmation Modal -->
    <div id="adminCancelModal" class="modal">
        <div class="modal-content">
            <h3><i class="fas fa-tools"></i> IT Support - Confirm Cancellation</h3>
            <p>Are you sure you want to cancel this booking?<br><br>This action cannot be undone.<br><br></p>
            <div class="modal-buttons">
                <button class="btn btn-danger" onclick="confirmCancellation()">Yes, Cancel Booking</button>
                <button class="btn btn-secondary" onclick="closeModal()">No, Keep Booking</button>
            </div>
        </div>
    </div>

    <!-- Admin Case Completed Confirmation Modal -->
    <div id="adminCaseCompletedModal" class="modal">
        <div class="modal-content">
            <h3><i class="fas fa-tools"></i> IT Support - Confirm Case Completion</h3>
            <p>Are you sure you want to mark this case as completed?<br><br>The slot will be freed up for new bookings.<br><br></p>
            <div class="modal-buttons">
                <button class="btn btn-success" onclick="markCaseCompleted()">Yes, Mark as Completed</button>
                <button class="btn btn-secondary" onclick="closeModal()">No, Keep Booking</button>
            </div>
        </div>
    </div>

    <!-- Admin Password Modal -->
    <div id="adminModal" class="modal">
        <div class="modal-content">
            <h3><i class="fas fa-user-shield"></i> Admin Access</h3>
            <p>Enter admin password:</p>
            <br><br>
            <input type="password" id="adminPasswordInput" placeholder="Enter admin password" maxlength="50">
            <br><br>
            <div class="modal-buttons">
                <button class="btn btn-primary" onclick="verifyAdminPassword()">Access Admin</button>
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Version management system
        // IMPORTANT: Update APP_VERSION in app.py when making changes (increment by 0.1)
        const APP_VERSION = "{{ version }}";
        
        function getCurrentVersion() {
            return APP_VERSION;
        }
        
        // CSRF token management
        function getCSRFToken() {
            const token = document.querySelector('meta[name=csrf-token]').getAttribute('content');
            return token && token.length > 0 ? token : null;
        }
        
        function incrementVersion() {
            const versionParts = APP_VERSION.split('.');
            const major = parseInt(versionParts[0]);
            const minor = parseFloat(versionParts[1]) + 0.1;
            return `${major}.${minor.toFixed(1)}`;
        }
        
        function updateVersionDisplay() {
            const versionElement = document.querySelector('#adminModal .modal-content div[style*="text-align: center"]');
            if (versionElement) {
                versionElement.innerHTML = `<i class="fas fa-code-branch"></i> Version ${getCurrentVersion()}`;
            }
        }
        
        // Production logging system
        const DEBUG_MODE = {{ debug_mode|tojson }};
        
        // Production-safe logging function
        function debugLog(message, ...args) {
            if (DEBUG_MODE) {
                debugLog(message, ...args);
            }
        }
        
        // Error logging (always enabled for production debugging)
        function errorLog(message, ...args) {
            console.error(message, ...args);
        }
        
        // WebSocket connection for real-time updates
        const socket = io();
        let isWebSocketConnected = false;
        
        // WebSocket event handlers
        socket.on('connect', function() {
            debugLog('Connected to real-time updates');
            isWebSocketConnected = true;
            joinDateRoom(currentDate);
        });
        
        socket.on('disconnect', function() {
            debugLog('Disconnected from real-time updates');
            isWebSocketConnected = false;
        });
        
        socket.on('booking_update', function(data) {
            debugLog('Received booking update:', data);
            handleRealTimeBookingUpdate(data);
        });
        
        socket.on('time_update', function(data) {
            debugLog('Received time update:', data);
            handleRealTimeTimeUpdate(data);
        });
        
        function joinDateRoom(date) {
            if (isWebSocketConnected) {
                socket.emit('join_date', { date: date });
                debugLog('Joined date room:', date);
            }
        }
        
        function leaveDateRoom(date) {
            if (isWebSocketConnected) {
                socket.emit('leave_date', { date: date });
                debugLog('Left date room:', date);
            }
        }
        
        function handleRealTimeBookingUpdate(data) {
            const { date, slot_key, booking_data, action } = data;
            
            if (date !== currentDate) return; // Only update if viewing the same date
            
            if (action === 'book' && booking_data) {
                // Update slot to booked state
                const slotElement = document.querySelector(`[data-time="${slot_key.split('_')[1]}"]`);
                if (slotElement) {
                    slotElement.classList.remove('available');
                    slotElement.classList.add('booked');
                    
                    // Update the booked text
                    const bookedText = slotElement.querySelector('.booked-text');
                    if (bookedText) {
                        bookedText.textContent = booking_data.username || 'Booked';
                        bookedText.style.display = 'block';
                    }
                    
                    // Add transient highlight
                    slotElement.classList.add('just-booked');
                    setTimeout(() => slotElement.classList.remove('just-booked'), 5000);
                }
                
                // Update local bookings object
                bookings[slot_key] = booking_data;
            } else if (action === 'cancel') {
                // Update slot to available state
                const slotElement = document.querySelector(`[data-time="${slot_key.split('_')[1]}"]`);
                if (slotElement) {
                    slotElement.classList.remove('booked');
                    slotElement.classList.add('available');
                    
                    // Hide the booked text
                    const bookedText = slotElement.querySelector('.booked-text');
                    if (bookedText) {
                        bookedText.style.display = 'none';
                    }
                }
                
                // Remove from local bookings object
                delete bookings[slot_key];
            }
        }
        
        function handleRealTimeTimeUpdate(data) {
            // Update time visualization with real-time data
            updateTimeVisualizationWithData(data);
        }
        
        let currentDate = '{{ dates[0].date }}';
        let currentSlot = null;
        let bookings = {};
        let autoRefreshInterval = null;
        let timeUpdateInterval = null;
        let deviceId = '';
        let isAdminSession = false;

        // Generate or retrieve device ID
        function getOrCreateDeviceId() {
            // Check if device ID exists in localStorage
            deviceId = localStorage.getItem('device_id');
            
            if (!deviceId) {
                // Generate a unique device ID based on browser fingerprint
                const timestamp = Date.now();
                const random = Math.random().toString(36).substr(2, 9);
                const userAgent = navigator.userAgent.substr(0, 50);
                deviceId = 'device_' + timestamp + '_' + random + '_' + btoa(userAgent).substr(0, 10);
                
                // Store in localStorage (persistent across sessions)
                localStorage.setItem('device_id', deviceId);
                debugLog('Generated new device ID:', deviceId);
            } else {
                debugLog('Using existing device ID:', deviceId);
            }
            
            return deviceId;
        }

        // Flag to prevent multiple calls during initialization
        let isInitializing = false;
        let isAdjustingPortrait = false; // Flag to prevent multiple portrait adjustments
        
        // Dynamic screen size detection and optimization - APPLY TO ALL DEVICES
        function detectScreenSize() {
            debugLog('detectScreenSize called, isInitializing:', isInitializing);
            
            // Skip if we're in the middle of initialization to prevent race conditions
            if (isInitializing) {
                debugLog('Skipping detectScreenSize - initialization in progress');
                return;
            }
            
            // Skip if we're in portrait mode to prevent re-calculations (except during initial load)
            const width = window.innerWidth;
            const height = window.innerHeight;
            if (width <= height && !isInitializing) {
                debugLog('Skipping detectScreenSize - portrait mode detected, preventing re-calculations');
                return;
            }
            
            try {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                // Ensure we have valid dimensions
                if (width <= 0 || height <= 0) {
                    debugLog('Invalid dimensions, retrying in 100ms...');
                    setTimeout(detectScreenSize, 100);
                    return;
                }
                
                // Mobile-specific viewport stability check
                // Simple viewport check - back to working approach
                if (width <= 0 || height <= 0) {
                    debugLog('Invalid dimensions, retrying in 100ms...');
                    setTimeout(detectScreenSize, 100);
                    return;
                }
                debugLog('Screen size:', width, 'x', height);
                
                // Apply strict container sizing to ALL devices
                    const container = document.querySelector('.container');
                    if (!container) return;
                    
                // Calculate container dimensions - STRICT: screen size minus 40px margins
                const containerWidth = width - 40; // 40px for left and right margins
                const footerHeight = 40; // Footer height
                const containerHeight = height - 40; // 40px for top and bottom margins
                
                // Apply container sizing and positioning for BOTH orientations
                if (width > height) {
                    // Landscape: Apply both dimensions and positioning with proper margins
                    container.style.setProperty('width', containerWidth + 'px', 'important');
                    container.style.setProperty('max-width', containerWidth + 'px', 'important');
                    container.style.setProperty('height', containerHeight + 'px', 'important');
                    container.style.setProperty('max-height', containerHeight + 'px', 'important');
                    container.style.setProperty('min-height', containerHeight + 'px', 'important');
                    container.style.setProperty('margin', '20px auto', 'important');
                    container.style.setProperty('position', 'relative', 'important');
                    container.style.setProperty('top', '0', 'important');
                    container.style.setProperty('left', '0', 'important');
                    container.style.setProperty('transform', 'none', 'important');
                    container.style.setProperty('overflow', 'hidden', 'important');
                    container.style.setProperty('box-sizing', 'border-box', 'important');
                } else {
                    // Portrait: Apply dimensions and positioning
                    container.style.setProperty('width', containerWidth + 'px', 'important');
                    container.style.setProperty('max-width', containerWidth + 'px', 'important');
                    container.style.setProperty('height', containerHeight + 'px', 'important');
                    container.style.setProperty('max-height', containerHeight + 'px', 'important');
                    container.style.setProperty('min-height', containerHeight + 'px', 'important');
                    container.style.setProperty('overflow', 'hidden', 'important');
                    container.style.setProperty('box-sizing', 'border-box', 'important');
                    container.style.setProperty('margin', '20px auto', 'important');
                    container.style.setProperty('position', 'relative', 'important');
                    container.style.setProperty('left', '0', 'important');
                    container.style.setProperty('right', '0', 'important');
                    container.style.setProperty('transform', 'none', 'important');
                }
                
                // Simple container positioning - back to working approach
                debugLog('Container dimensions set:', containerWidth + 'x' + containerHeight);
                debugLog('Screen dimensions:', width + 'x' + height);
                debugLog('Container should have 20px margins on all sides');
                
                debugLog('Container dimensions:', containerWidth + 'x' + containerHeight);
                
                // Apply dynamic height calculations only for landscape orientation (width > height)
                if (width > height) {
                    // Force container to exact height before calling layout function
                    container.style.setProperty('height', containerHeight + 'px', 'important');
                    container.style.setProperty('max-height', containerHeight + 'px', 'important');
                    container.style.setProperty('min-height', containerHeight + 'px', 'important');
                    container.style.setProperty('overflow', 'hidden', 'important');
                    
                    // Call landscape-specific layout function immediately for landscape mode
                    adjustLandscapeLayout(width, height);
                } else {
                    // For portrait orientation, just apply container sizing
                    debugLog('Portrait orientation detected, applying container sizing only');
                    applyContainerSizing();
                }
            } catch (error) {
                console.error('Error in detectScreenSize:', error);
            }
        }
        
        function adjustLandscapeLayout(width, height) {
            try {
                const container = document.querySelector('.container');
                if (!container) return;
                
                // Reset Admin button to normal state for landscape mode
                resetAdminButtonForLandscape();
                
                // Use the calculated container height, not the actual offsetHeight which might be different
                const containerHeight = height - 40; // Same calculation as detectScreenSize
                
                // Get heights of fixed elements
                const header = document.querySelector('.header');
                const dateSelector = document.querySelector('.date-selector');
                const bookingGrid = document.querySelector('.booking-grid');
                const morningSlots = document.querySelector('#morningSlots');
                const afternoonSlots = document.querySelector('#afternoonSlots');
                
                if (header && dateSelector && bookingGrid && morningSlots && afternoonSlots) {
                    // Use the calculated container height
                    debugLog('Container height:', containerHeight + 'px');
                    
                    // Calculate heights of fixed elements
                    const headerHeight = header.offsetHeight;
                    const footerHeight = 40; // Footer height
                    
                    // Calculate usable space: container height minus header and footer
                    const usableHeight = containerHeight - headerHeight - footerHeight;
                    debugLog('Header height:', headerHeight + 'px');
                    debugLog('Footer height:', footerHeight + 'px');
                    debugLog('Usable space (header to footer):', usableHeight + 'px');
                    
                    // Calculate heights of content elements within usable space
                    const dateSelectorHeight = dateSelector.offsetHeight;
                    const lunchBreakHeight = document.querySelector('.lunch-break')?.offsetHeight || 0;
                    const sectionHeadersHeight = Array.from(document.querySelectorAll('.section-header')).reduce((total, header) => total + header.offsetHeight, 0);
                    
                    // Calculate available height for time slots (usable space minus content elements)
                    const contentHeights = dateSelectorHeight + lunchBreakHeight + sectionHeadersHeight + 80; // 80px for padding/margins (very conservative)
                    const availableHeight = usableHeight - contentHeights;
                    
                    debugLog('Date selector height:', dateSelectorHeight + 'px');
                    debugLog('Lunch break height:', lunchBreakHeight + 'px');
                    debugLog('Section headers height:', sectionHeadersHeight + 'px');
                    debugLog('Content heights total:', contentHeights + 'px');
                    debugLog('Available height for time slots:', availableHeight + 'px');
                    
                    // Calculate optimal dimensions for time slot buttons to fully utilize usable space
                    const morningSlotsCount = morningSlots.children.length; // 12 slots
                    const afternoonSlotsCount = afternoonSlots.children.length; // 16 slots
                    const totalSlots = morningSlotsCount + afternoonSlotsCount;
                    
                    // Get container width for width calculations
                    const containerWidth = container.offsetWidth;
                    const availableWidth = containerWidth - 40; // Account for container padding
                    
                    // Calculate grid dimensions (6 columns for landscape)
                    const columns = 6;
                    const morningRows = Math.ceil(morningSlotsCount / columns); // 2 rows
                    const afternoonRows = Math.ceil(afternoonSlotsCount / columns); // 3 rows
                    const totalRows = morningRows + afternoonRows; // 5 rows total
                    
                    // Calculate optimal button dimensions
                    const buttonWidth = Math.floor((availableWidth - (columns - 1) * 8) / columns); // Account for 8px gaps
                    const buttonHeight = Math.floor(availableHeight / totalRows); // Distribute height evenly across rows
                    
                    // Safety check: ensure button height doesn't exceed available space with extra buffer
                    const maxButtonHeight = Math.floor((availableHeight - 20) / totalRows); // 20px extra buffer
                    const finalButtonHeight = Math.min(buttonHeight, maxButtonHeight);
                    
                    debugLog('Container width:', containerWidth + 'px');
                    debugLog('Available width:', availableWidth + 'px');
                    debugLog('Morning slots count:', morningSlotsCount, '(rows:', morningRows + ')');
                    debugLog('Afternoon slots count:', afternoonSlotsCount, '(rows:', afternoonRows + ')');
                    debugLog('Total rows:', totalRows);
                    debugLog('Calculated button width:', buttonWidth + 'px');
                    debugLog('Calculated button height:', finalButtonHeight + 'px');
                    
                    // Verify total height doesn't exceed available space
                    const totalSlotsHeight = finalButtonHeight * totalRows;
                    debugLog('Total slots height:', totalSlotsHeight + 'px');
                    debugLog('Height utilization:', Math.round((totalSlotsHeight / availableHeight) * 100) + '%');
                    
                    // Apply calculated dimensions to time slot buttons
                    const allTimeSlots = document.querySelectorAll('.time-slot');
                    debugLog('Found time slots:', allTimeSlots.length);
                    debugLog('Applying dimensions - Width:', buttonWidth + 'px', 'Height:', finalButtonHeight + 'px');
                    
                    allTimeSlots.forEach((slot, index) => {
                        slot.style.setProperty('width', buttonWidth + 'px', 'important');
                        slot.style.setProperty('height', finalButtonHeight + 'px', 'important');
                        slot.style.setProperty('min-height', finalButtonHeight + 'px', 'important');
                        slot.style.setProperty('max-height', finalButtonHeight + 'px', 'important');
                        slot.style.setProperty('flex-shrink', '0', 'important');
                        
                        if (index < 3) { // Log first 3 slots for debugging
                            debugLog(`Slot ${index + 1} dimensions applied:`, slot.style.width, slot.style.height);
                        }
                    });
                    
                    // Set container heights using the calculated button height
                    const morningContainerHeight = finalButtonHeight * morningRows;
                    const afternoonContainerHeight = finalButtonHeight * afternoonRows;
                    
                    // Apply heights to slot containers
                    morningSlots.style.height = morningContainerHeight + 'px';
                    afternoonSlots.style.height = afternoonContainerHeight + 'px';
                    
                    // Align lunch break width with time slot grid
                    const lunchBreak = document.querySelector('.lunch-break');
                    if (lunchBreak) {
                        // Calculate the exact width of the time slot grid
                        const gridWidth = (buttonWidth * columns) + ((columns - 1) * 8); // 8px gap between slots
                        lunchBreak.style.width = gridWidth + 'px';
                        lunchBreak.style.margin = '10px auto';
                        debugLog('Lunch break width set to:', gridWidth + 'px');
                    }
                    
                    // Verify content fits within container
                    const totalContentHeight = contentHeights + totalSlotsHeight;
                    debugLog('Total content height:', totalContentHeight + 'px');
                    debugLog('Container height:', containerHeight + 'px');
                    debugLog('Content fits in container:', totalContentHeight <= containerHeight);
                    
                    // Final safety check: if still too close to container edge, reduce button height further
                    if (totalContentHeight > (containerHeight - 10)) {
                        const excessHeight = totalContentHeight - (containerHeight - 10);
                        const heightReduction = Math.ceil(excessHeight / totalRows) + 5;
                        const emergencyButtonHeight = Math.max(30, finalButtonHeight - heightReduction);
                        
                        debugLog('Emergency height reduction applied:', emergencyButtonHeight + 'px');
                        
                        // Reapply with emergency height
                        allTimeSlots.forEach(slot => {
                            slot.style.setProperty('height', emergencyButtonHeight + 'px', 'important');
                            slot.style.setProperty('min-height', emergencyButtonHeight + 'px', 'important');
                            slot.style.setProperty('max-height', emergencyButtonHeight + 'px', 'important');
                        });
                        
                        // Recalculate container heights
                        const emergencyMorningHeight = emergencyButtonHeight * morningRows;
                        const emergencyAfternoonHeight = emergencyButtonHeight * afternoonRows;
                        
                        morningSlots.style.height = emergencyMorningHeight + 'px';
                        afternoonSlots.style.height = emergencyAfternoonHeight + 'px';
                        
                        debugLog('Emergency dimensions applied to prevent cutoff');
                    }
                    
                    // Safety check: if content exceeds container, reduce button heights
                    if (totalContentHeight > containerHeight) {
                        const excessHeight = totalContentHeight - containerHeight;
                        const heightReduction = Math.ceil(excessHeight / totalRows) + 5; // Add 5px buffer
                        const adjustedButtonHeight = Math.max(30, buttonHeight - heightReduction);
                        
                        debugLog('Content exceeds container, adjusting button heights...');
                        debugLog('Excess height:', excessHeight + 'px');
                        debugLog('Height reduction per row:', heightReduction + 'px');
                        debugLog('Adjusted button height:', adjustedButtonHeight + 'px');
                        
                        // Reapply with adjusted height
                        allTimeSlots.forEach(slot => {
                            slot.style.height = adjustedButtonHeight + 'px';
                            slot.style.minHeight = adjustedButtonHeight + 'px';
                            slot.style.maxHeight = adjustedButtonHeight + 'px';
                        });
                        
                        // Recalculate container heights
                        const adjustedMorningHeight = adjustedButtonHeight * morningRows;
                        const adjustedAfternoonHeight = adjustedButtonHeight * afternoonRows;
                        
                        morningSlots.style.height = adjustedMorningHeight + 'px';
                        afternoonSlots.style.height = adjustedAfternoonHeight + 'px';
                        
                        debugLog('Button dimensions adjusted for container fit');
                    }
                    
                    //                     
                    //                     const bookingGrid = document.querySelector('.booking-grid');
                    if (bookingGrid) {
                        bookingGrid.style.flex = '1';
                        bookingGrid.style.display = 'flex';
                        bookingGrid.style.flexDirection = 'column';
                    }
                    
                    // Set scrollable content height to usable space and enable scrolling for landscape
                    const scrollableContent = document.querySelector('.scrollable-content');
                    if (scrollableContent) {
                        scrollableContent.style.height = usableHeight + 'px';
                        scrollableContent.style.maxHeight = usableHeight + 'px';
                        scrollableContent.style.overflow = 'auto'; // Enable scrolling for landscape
                        debugLog('Scrollable content height set to:', usableHeight + 'px');
                    }
                    
                    // Position footer at bottom of container
                    const footerSection = document.querySelector('.footer-section');
                    if (footerSection) {
                        footerSection.style.position = 'absolute';
                        footerSection.style.bottom = '0';
                        footerSection.style.left = '0';
                        footerSection.style.width = '100%';
                        footerSection.style.height = '40px';
                        footerSection.style.zIndex = '10';
                        debugLog('Footer positioned at bottom of container');
                    }
                    
                }
                
                debugLog('Landscape dynamic layout applied successfully');
                
                
                // Final enforcement: Ensure container height is exactly what we calculated
                container.style.setProperty('height', containerHeight + 'px', 'important');
                container.style.setProperty('max-height', containerHeight + 'px', 'important');
                container.style.setProperty('min-height', containerHeight + 'px', 'important');
                container.style.setProperty('overflow', 'hidden', 'important');
                debugLog('Final container height enforcement:', containerHeight + 'px');
                
            } catch (error) {
                console.error('Error in adjustLandscapeLayout:', error);
            }
        }
        
        
        // Apply container sizing for portrait orientation
        function applyContainerSizing() {
            try {
                const container = document.querySelector('.container');
                if (!container) return;
                
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                // Apply strict container sizing
                const containerWidth = width - 40;
                const containerHeight = Math.min(height - 40, window.innerHeight - 40);
                
                container.style.setProperty('width', containerWidth + 'px', 'important');
                container.style.setProperty('max-width', containerWidth + 'px', 'important');
                container.style.setProperty('height', containerHeight + 'px', 'important');
                container.style.setProperty('max-height', containerHeight + 'px', 'important');
                container.style.setProperty('overflow', 'hidden', 'important');
                container.style.setProperty('position', 'relative', 'important');
                
                // Calculate usable space for portrait mode
                const header = document.querySelector('.header');
                const footerHeight = 40; // Updated footer height
                const headerHeight = header ? header.offsetHeight : 0;
                const usableHeight = containerHeight - headerHeight - footerHeight;
                
                // Set scrollable content height to usable space
                const scrollableContent = document.querySelector('.scrollable-content');
                if (scrollableContent) {
                    scrollableContent.style.height = usableHeight + 'px';
                    scrollableContent.style.maxHeight = usableHeight + 'px';
                    scrollableContent.style.overflow = 'auto'; // Enable scrolling in portrait
                    debugLog('Portrait scrollable content height set to:', usableHeight + 'px');
                }
                
                // Position footer at bottom of container for portrait
                const footerSection = document.querySelector('.footer-section');
                if (footerSection) {
                    footerSection.style.position = 'absolute';
                    footerSection.style.bottom = '0';
                    footerSection.style.left = '0';
                    footerSection.style.width = '100%';
                    footerSection.style.height = '40px';
                    footerSection.style.zIndex = '10';
                    debugLog('Footer positioned at bottom of container (portrait)');
                }
                
                // Apply portrait-specific CSS via JavaScript
                applyPortraitCSS();
                
                // Add dynamic time slot height calculation for portrait (single call to prevent multiple adjustments)
                setTimeout(() => {
                    adjustPortraitLayout(containerWidth, containerHeight);
                }, 100);
                
                debugLog('Container sizing applied for portrait orientation:', containerWidth + 'x' + containerHeight);
            } catch (error) {
                console.error('Error in applyContainerSizing:', error);
            }
        }
        
        function applyPortraitCSS() {
            try {
                debugLog('Applying portrait-specific CSS via JavaScript...');
                
                // Force Admin button to be circular in portrait mode
                const adminBtn = document.querySelector('.admin-btn');
                if (adminBtn) {
                    adminBtn.style.setProperty('width', '50px', 'important');
                    adminBtn.style.setProperty('height', '50px', 'important');
                    adminBtn.style.setProperty('border-radius', '50%', 'important');
                    adminBtn.style.setProperty('padding', '0', 'important');
                    adminBtn.style.setProperty('display', 'flex', 'important');
                    adminBtn.style.setProperty('align-items', 'center', 'important');
                    adminBtn.style.setProperty('justify-content', 'center', 'important');
                    adminBtn.style.setProperty('font-size', '1.2rem', 'important');
                    adminBtn.style.setProperty('position', 'absolute', 'important');
                    adminBtn.style.setProperty('top', '20px', 'important');
                    adminBtn.style.setProperty('right', '20px', 'important');
                    
                    // Update button text for portrait mode (icon only)
                    updateAdminButtonText();
                    
                    // Reset icon margins
                    const adminIcon = adminBtn.querySelector('i');
                    if (adminIcon) {
                        adminIcon.style.setProperty('margin', '0', 'important');
                    }
                    
                    debugLog('Admin button styled for portrait mode');
                }
                
                // Apply portrait-specific time slot styling
                const timeSlots = document.querySelectorAll('.time-slot');
                timeSlots.forEach(slot => {
                    // min-height removed to allow dynamic height calculation
                    slot.style.setProperty('padding', '10px', 'important');
                });
                
                debugLog('Portrait CSS applied successfully');
            } catch (error) {
                console.error('Error applying portrait CSS:', error);
            }
        }
        
        function adjustPortraitLayout(containerWidth, containerHeight) {
            // Prevent multiple simultaneous adjustments
            if (isAdjustingPortrait) {
                debugLog('Portrait adjustment already in progress, skipping...');
                return;
            }
            
            isAdjustingPortrait = true;
            
            try {
                debugLog('=== ADJUSTING PORTRAIT LAYOUT ===');
                debugLog('Container dimensions:', containerWidth + 'x' + containerHeight);
                
                // Get heights of fixed elements
                const header = document.querySelector('.header');
                const dateSelector = document.querySelector('.date-selector');
                const lunchBreak = document.querySelector('.lunch-break');
                const sectionHeaders = document.querySelectorAll('.section-header');
                
                const headerHeight = header ? header.offsetHeight : 0;
                const dateSelectorHeight = dateSelector ? dateSelector.offsetHeight : 0;
                const lunchBreakHeight = lunchBreak ? lunchBreak.offsetHeight : 0;
                const sectionHeadersHeight = Array.from(sectionHeaders).reduce((total, header) => total + header.offsetHeight, 0);
                const footerHeight = 40;
                
                // Calculate usable space: container height minus header and footer
                const usableHeight = containerHeight - headerHeight - footerHeight;
                
                // Calculate content heights (date selector + lunch break + section headers + ultra minimal padding)
                const contentHeights = dateSelectorHeight + lunchBreakHeight + sectionHeadersHeight + 5; // Ultra reduced to 5px for padding/margins
                const availableHeight = usableHeight - contentHeights;
                
                debugLog('Portrait layout calculations:');
                debugLog('Container height:', containerHeight + 'px');
                debugLog('Header height:', headerHeight + 'px');
                debugLog('Footer height:', footerHeight + 'px');
                debugLog('Usable height:', usableHeight + 'px');
                debugLog('Date selector height:', dateSelectorHeight + 'px');
                debugLog('Lunch break height:', lunchBreakHeight + 'px');
                debugLog('Section headers height:', sectionHeadersHeight + 'px');
                debugLog('Content heights total:', contentHeights + 'px');
                debugLog('Available height for time slots:', availableHeight + 'px');
                
                // Get all time slots
                const allTimeSlots = document.querySelectorAll('.time-slot');
                const morningSlots = document.querySelectorAll('#morningSlots .time-slot');
                const afternoonSlots = document.querySelectorAll('#afternoonSlots .time-slot');
                
                const morningSlotsCount = morningSlots.length;
                const afternoonSlotsCount = afternoonSlots.length;
                const totalSlots = allTimeSlots.length;
                
                debugLog('Time slots count - Morning:', morningSlotsCount, 'Afternoon:', afternoonSlotsCount, 'Total:', totalSlots);
                
                if (totalSlots > 0 && availableHeight > 0) {
                    // Portrait mode: 4 columns for time slots
                    const columns = 4;
                    const morningRows = Math.ceil(morningSlotsCount / columns);
                    const afternoonRows = Math.ceil(afternoonSlotsCount / columns);
                    const totalRows = morningRows + afternoonRows;
                    
                    // Calculate button dimensions
                    const availableWidth = containerWidth - 40; // Account for container padding
                    const buttonWidth = Math.floor((availableWidth - (columns - 1) * 8) / columns); // Account for gaps
                    
                    // ULTRA-AGGRESSIVE height calculation to eliminate white space
                    const minButtonHeight = 15; // Ultra minimal minimum height
                    let buttonHeight = Math.floor(availableHeight * 1.05 / totalRows); // Start with 105% of available height
                    
                    debugLog('Initial button height calculation:', buttonHeight + 'px');
                    debugLog('Available height per row:', Math.floor(availableHeight / totalRows) + 'px');
                    
                    // Ensure minimum height but be very aggressive
                    buttonHeight = Math.max(minButtonHeight, buttonHeight);
                    
                    // Calculate what the total height would be
                    let totalContentHeight = (buttonHeight * totalRows) + contentHeights;
                    let remainingSpace = usableHeight - totalContentHeight;
                    
                    debugLog('After initial calculation:');
                    debugLog('Total content height:', totalContentHeight + 'px');
                    debugLog('Remaining space:', remainingSpace + 'px');
                    
                    // If we have ANY remaining space, use it all
                    if (remainingSpace > 1) {
                        const extraHeight = Math.floor(remainingSpace / totalRows);
                        if (extraHeight > 0) {
                            buttonHeight += extraHeight;
                            totalContentHeight = (buttonHeight * totalRows) + contentHeights;
                            remainingSpace = usableHeight - totalContentHeight;
                            debugLog('Added extra height:', extraHeight + 'px');
                            debugLog('New remaining space:', remainingSpace + 'px');
                        }
                    }
                    
                    // Final ultra-aggressive check: if still space left, use it
                    if (remainingSpace > 0) {
                        const finalExtra = Math.floor(remainingSpace / totalRows);
                        if (finalExtra > 0) {
                            buttonHeight += finalExtra;
                            debugLog('Final extra height added:', finalExtra + 'px');
                        }
                        
                        // Even more aggressive: add 1px to each row if there's still space
                        if (remainingSpace > totalRows) {
                            buttonHeight += 1;
                            debugLog('Added 1px more to each row for maximum space utilization');
                        }
                    }
                    
                    // Only reduce if we're actually overflowing
                    const finalTotalHeight = (buttonHeight * totalRows) + contentHeights;
                    if (finalTotalHeight > usableHeight + 5) { // Allow 5px tolerance
                        buttonHeight = Math.floor((usableHeight - contentHeights) / totalRows);
                        debugLog('EMERGENCY: Reduced button height to fit:', buttonHeight + 'px');
                    }
                    
                    debugLog('FINAL button height:', buttonHeight + 'px');
                    debugLog('FINAL total height:', (buttonHeight * totalRows) + contentHeights + 'px');
                    debugLog('FINAL remaining space:', usableHeight - ((buttonHeight * totalRows) + contentHeights) + 'px');
                    
                    debugLog('Portrait button calculations:');
                    debugLog('Columns:', columns);
                    debugLog('Morning rows:', morningRows);
                    debugLog('Afternoon rows:', afternoonRows);
                    debugLog('Total rows:', totalRows);
                    debugLog('Button width:', buttonWidth + 'px');
                    debugLog('Button height:', buttonHeight + 'px');
                    
                    // Apply dimensions to all time slots
                    allTimeSlots.forEach(slot => {
                        slot.style.setProperty('width', buttonWidth + 'px', 'important');
                        slot.style.setProperty('height', buttonHeight + 'px', 'important');
                        slot.style.setProperty('min-height', buttonHeight + 'px', 'important');
                        slot.style.setProperty('box-sizing', 'border-box', 'important');
                        slot.style.setProperty('flex-shrink', '0', 'important');
                        
                        // Force the height with direct assignment to override any CSS
                        slot.style.height = buttonHeight + 'px';
                        slot.style.minHeight = buttonHeight + 'px';
                        slot.style.maxHeight = buttonHeight + 'px';
                    });
                    
                    // Adjust lunch break width to match time slot grid
                    if (lunchBreak) {
                        const gridWidth = (buttonWidth * columns) + ((columns - 1) * 8); // 8px gap between slots
                        lunchBreak.style.width = gridWidth + 'px';
                        lunchBreak.style.margin = '10px auto';
                        debugLog('Lunch break width set to:', gridWidth + 'px');
                    }
                    
                    debugLog('Portrait layout adjustment completed');
                    
                    // Final height enforcement - ensure all slots use the calculated height
                    setTimeout(() => {
                        const finalSlots = document.querySelectorAll('.time-slot');
                        finalSlots.forEach(slot => {
                            slot.style.height = buttonHeight + 'px';
                            slot.style.minHeight = buttonHeight + 'px';
                            slot.style.maxHeight = buttonHeight + 'px';
                        });
                        debugLog('Final height enforcement applied:', buttonHeight + 'px');
                    }, 50);
                    
                    // Force a final check and adjustment
                    setTimeout(() => {
                        const finalSlots = document.querySelectorAll('.time-slot');
                        if (finalSlots.length > 0) {
                            debugLog('=== FINAL PORTRAIT HEIGHT CHECK ===');
                            const container = document.querySelector('.container');
                            if (container) {
                                const currentContainerHeight = container.offsetHeight;
                                const header = document.querySelector('.header');
                                const footer = document.querySelector('.footer-section');
                                const headerHeight = header ? header.offsetHeight : 0;
                                const footerHeight = footer ? footer.offsetHeight : 40;
                                const currentUsableHeight = currentContainerHeight - headerHeight - footerHeight;
                                
                                debugLog('Final check - Container height:', currentContainerHeight);
                                debugLog('Final check - Usable height:', currentUsableHeight);
                                
                                // If we still have significant unused space, force larger buttons
                                const currentButtonHeight = finalSlots[0].offsetHeight;
                                const totalRows = Math.ceil(finalSlots.length / 4);
                                const currentTotalHeight = (currentButtonHeight * totalRows) + contentHeights;
                                const unusedSpace = currentUsableHeight - currentTotalHeight;
                                
                                debugLog('Final check - Current button height:', currentButtonHeight);
                                debugLog('Final check - Unused space:', unusedSpace);
                                
                                if (unusedSpace > 20) {
                                    const extraHeight = Math.floor(unusedSpace / totalRows);
                                    if (extraHeight > 0) {
                                        debugLog('FORCING extra height:', extraHeight + 'px');
                                        finalSlots.forEach(slot => {
                                            const newHeight = currentButtonHeight + extraHeight;
                                            slot.style.height = newHeight + 'px';
                                            slot.style.minHeight = newHeight + 'px';
                                            slot.style.maxHeight = newHeight + 'px';
                                        });
                                    }
                                }
                            }
                        }
                    }, 200);
                } else {
                    debugLog('No time slots found or no available height for portrait layout');
                }
                
            } catch (error) {
                console.error('Error in adjustPortraitLayout:', error);
            } finally {
                // Reset the flag after adjustment is complete
                isAdjustingPortrait = false;
            }
        }

        // Reset Admin button to normal state for landscape mode
        function resetAdminButtonForLandscape() {
            const adminBtn = document.querySelector('.admin-btn');
            if (adminBtn) {
                debugLog('Resetting Admin button for landscape mode');
                adminBtn.style.width = '';
                adminBtn.style.height = '';
                adminBtn.style.borderRadius = '';
                adminBtn.style.padding = '';
                adminBtn.style.display = '';
                adminBtn.style.alignItems = '';
                adminBtn.style.justifyContent = '';
                adminBtn.style.fontSize = '';
                
                // Update button text based on admin state
                updateAdminButtonText();
                
                // Reset icon margin
                const adminIcon = adminBtn.querySelector('i');
                if (adminIcon) {
                    adminIcon.style.margin = '';
                }
            }
        }

        // Force portrait mode fixes immediately
        function forcePortraitFixes() {
            debugLog('=== FORCING portrait mode fixes ===');
            debugLog('Current window dimensions:', window.innerWidth + 'x' + window.innerHeight);
            debugLog('Orientation:', window.innerWidth > window.innerHeight ? 'landscape' : 'portrait');
            
            // Only apply portrait fixes if we're actually in portrait mode
            const isPortrait = window.innerWidth <= window.innerHeight;
            if (!isPortrait) {
                debugLog('Not in portrait mode, skipping portrait fixes');
                return;
            }
            
            // Add a visual indicator that the function is running
            debugLog('🔧 FORCE PORTRAIT FIXES FUNCTION IS RUNNING 🔧');
            
            // Force Admin button to be circular
            const adminBtn = document.querySelector('.admin-btn');
            debugLog('Admin button found:', !!adminBtn);
            if (adminBtn) {
                debugLog('Admin button current styles:');
                debugLog('- width:', adminBtn.style.width || 'not set');
                debugLog('- height:', adminBtn.style.height || 'not set');
                debugLog('- borderRadius:', adminBtn.style.borderRadius || 'not set');
                debugLog('- display:', adminBtn.style.display || 'not set');
                
                debugLog('Applying circular styling...');
                adminBtn.style.width = '50px';
                adminBtn.style.height = '50px';
                adminBtn.style.borderRadius = '50%';
                adminBtn.style.padding = '0';
                adminBtn.style.display = 'flex';
                adminBtn.style.alignItems = 'center';
                adminBtn.style.justifyContent = 'center';
                adminBtn.style.fontSize = '1.2rem';
                adminBtn.style.position = 'absolute';
                adminBtn.style.top = '20px';
                adminBtn.style.right = '20px';
                
                // Update button text for portrait mode (icon only)
                updateAdminButtonText();
                
                // Reset icon margins
                const adminIcon = adminBtn.querySelector('i');
                debugLog('Admin icon found:', !!adminIcon);
                if (adminIcon) {
                    adminIcon.style.margin = '0';
                    debugLog('Admin icon margin reset');
                }
                
                debugLog('Admin button styling completed');
                debugLog('Final admin button styles:');
                debugLog('- width:', adminBtn.style.width);
                debugLog('- height:', adminBtn.style.height);
                debugLog('- borderRadius:', adminBtn.style.borderRadius);
                debugLog('- display:', adminBtn.style.display);
            } else {
                debugLog('ERROR: Admin button not found!');
            }
            
            // Force time slot height calculation
            setTimeout(() => {
                debugLog('=== Starting time slot height calculation ===');
                const container = document.querySelector('.container');
                debugLog('Container found:', !!container);
                if (container) {
                    const containerWidth = container.offsetWidth;
                    const containerHeight = container.offsetHeight;
                    debugLog('Container dimensions:', containerWidth + 'x' + containerHeight);
                    
                    // Get all time slots
                    const allTimeSlots = document.querySelectorAll('.time-slot');
                    debugLog('Found time slots:', allTimeSlots.length);
                    
                    if (allTimeSlots.length === 0) {
                        debugLog('ERROR: No time slots found! This might be the issue.');
                        return;
                    }
                    
                    if (allTimeSlots.length > 0) {
                        // Calculate available space more aggressively
                        const header = document.querySelector('.header');
                        const footer = document.querySelector('.footer-section');
                        const dateSelector = document.querySelector('.date-selector');
                        const lunchBreak = document.querySelector('.lunch-break');
                        const sectionHeaders = document.querySelectorAll('.section-header');
                        
                        const headerHeight = header ? header.offsetHeight : 0;
                        const footerHeight = footer ? footer.offsetHeight : 40;
                        const dateSelectorHeight = dateSelector ? dateSelector.offsetHeight : 0;
                        const lunchBreakHeight = lunchBreak ? lunchBreak.offsetHeight : 0;
                        const sectionHeadersHeight = Array.from(sectionHeaders).reduce((total, h) => total + h.offsetHeight, 0);
                        
                        const usableHeight = containerHeight - headerHeight - footerHeight;
                        const contentHeights = dateSelectorHeight + lunchBreakHeight + sectionHeadersHeight + 20; // Minimal padding
                        const availableHeight = usableHeight - contentHeights;
                        
                        debugLog('Height calculations:');
                        debugLog('- Container height:', containerHeight);
                        debugLog('- Header height:', headerHeight);
                        debugLog('- Footer height:', footerHeight);
                        debugLog('- Usable height:', usableHeight);
                        debugLog('- Content heights:', contentHeights);
                        debugLog('- Available height:', availableHeight);
                        
                        // Calculate button dimensions for portrait mode
                        const columns = 4; // Portrait mode should have 4 columns
                        const morningSlots = document.querySelectorAll('#morningSlots .time-slot');
                        const afternoonSlots = document.querySelectorAll('#afternoonSlots .time-slot');
                        const morningRows = Math.ceil(morningSlots.length / columns);
                        const afternoonRows = Math.ceil(afternoonSlots.length / columns);
                        const totalRows = morningRows + afternoonRows;
                        
                        const buttonWidth = Math.floor((containerWidth - 40 - (columns - 1) * 8) / columns);
                        let buttonHeight = Math.floor(availableHeight / totalRows);
                        
                        // Make it more aggressive
                        buttonHeight = Math.max(60, Math.floor(availableHeight * 0.9 / totalRows));
                        
                        debugLog('Button calculations:');
                        debugLog('- Total rows:', totalRows);
                        debugLog('- Button width:', buttonWidth);
                        debugLog('- Button height:', buttonHeight);
                        
                        // Apply to all time slots
                        allTimeSlots.forEach((slot, index) => {
                            slot.style.width = buttonWidth + 'px';
                            slot.style.height = Math.max(60, buttonHeight) + 'px';
                            slot.style.minHeight = Math.max(60, buttonHeight) + 'px';
                            slot.style.boxSizing = 'border-box';
                            slot.style.flexShrink = '0';
                            
                            if (index < 5) { // Log first few slots
                                debugLog(`Slot ${index}: ${slot.dataset.time} - ${buttonWidth}x${buttonHeight}`);
                            }
                        });
                        
                        debugLog('Time slots forced to new dimensions');
                    }
                }
            }, 100);
        }
        
        // Add event listeners using event delegation (more reliable)
        document.addEventListener('DOMContentLoaded', function() {
            debugLog('=== PAGE LOADED - DOMContentLoaded event fired ===');
            debugLog('Page loaded, initializing...'); // Debug log
            
            // Simple initialization - no complex mobile detection
            debugLog('DOMContentLoaded - starting simple initialization');
            
            // Immediate container positioning fix for both orientations
            const container = document.querySelector('.container');
            if (container) {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                debugLog('Immediate positioning - Screen:', width + 'x' + height);
                
                if (width > height) { // Landscape mode
                    debugLog('Landscape mode detected - applying immediate positioning');
                    container.style.width = (width - 40) + 'px';
                    container.style.height = (height - 40) + 'px';
                    container.style.minHeight = (height - 40) + 'px';
                    container.style.margin = '20px auto';
                    container.style.position = 'relative';
                    container.style.top = '0';
                    container.style.left = '0';
                    container.style.transform = 'none';
                    container.style.overflow = 'hidden';
                    container.style.maxHeight = (height - 40) + 'px';
                    debugLog('Landscape immediate positioning applied');
                    
                    // Apply immediate time slot sizing to prevent scale-up effect
                    debugLog('DOMContentLoaded - applying immediate landscape layout');
                    adjustLandscapeLayout(width, height);
                } else { // Portrait mode
                    debugLog('Portrait mode detected - applying immediate positioning');
                    container.style.width = (width - 40) + 'px';
                    container.style.height = (height - 40) + 'px';
                    container.style.minHeight = (height - 40) + 'px';
                    container.style.margin = '20px auto';
                    container.style.position = 'relative';
                    container.style.left = '0';
                    container.style.right = '0';
                    container.style.transform = 'none';
                    container.style.overflow = 'hidden';
                    container.style.maxHeight = (height - 40) + 'px';
                    debugLog('Portrait immediate positioning applied');
                }
            }
            
            // Portrait fixes will be handled by the proper initialization flow
            
            // Apply fixes multiple times to ensure they work
            function applyDirectFixes() {
                // Check if we're in portrait mode
                const isPortrait = window.innerWidth <= window.innerHeight;
                
                if (isPortrait) {
                    // Direct Admin button fix for portrait mode
                    const adminBtn = document.querySelector('.admin-btn');
                    if (adminBtn) {
                        adminBtn.style.width = '50px';
                        adminBtn.style.height = '50px';
                        adminBtn.style.borderRadius = '50%';
                        adminBtn.style.padding = '0';
                        adminBtn.style.display = 'flex';
                        adminBtn.style.alignItems = 'center';
                        adminBtn.style.justifyContent = 'center';
                        
                        const adminText = adminBtn.querySelector('span');
                        if (adminText) {
                            adminText.style.display = 'none';
                        }
                    }
                    
                    // Direct time slot height fix for portrait mode
                    const allTimeSlots = document.querySelectorAll('.time-slot');
                    if (allTimeSlots.length > 0) {
                        const container = document.querySelector('.container');
                        if (container) {
                            const containerHeight = container.offsetHeight;
                            const header = document.querySelector('.header');
                            const footer = document.querySelector('.footer-section');
                            const headerHeight = header ? header.offsetHeight : 0;
                            const footerHeight = footer ? footer.offsetHeight : 40;
                            const usableHeight = containerHeight - headerHeight - footerHeight;
                            
                            // Add safety margins for other content (date selector, lunch break, section headers)
                            const dateSelector = document.querySelector('.date-selector');
                            const lunchBreak = document.querySelector('.lunch-break');
                            const sectionHeaders = document.querySelectorAll('.section-header');
                            
                            const dateSelectorHeight = dateSelector ? dateSelector.offsetHeight : 0;
                            const lunchBreakHeight = lunchBreak ? lunchBreak.offsetHeight : 0;
                            const sectionHeadersHeight = Array.from(sectionHeaders).reduce((total, header) => total + header.offsetHeight, 0);
                            
                            const contentHeights = dateSelectorHeight + lunchBreakHeight + sectionHeadersHeight + 60; // 60px for padding/margins and safety
                            const availableHeight = usableHeight - contentHeights;
                            
                            // Calculate button dimensions for portrait mode
                            const columns = 4; // Portrait mode should have 4 columns, not 2
                            const morningSlots = document.querySelectorAll('#morningSlots .time-slot');
                            const afternoonSlots = document.querySelectorAll('#afternoonSlots .time-slot');
                            const morningRows = Math.ceil(morningSlots.length / columns);
                            const afternoonRows = Math.ceil(afternoonSlots.length / columns);
                            const totalRows = morningRows + afternoonRows;
                            
                            // Calculate button width - ensure it fits in container
                            const containerWidth = container.offsetWidth;
                            const availableWidth = containerWidth - 40; // Account for container padding
                            const buttonWidth = Math.floor((availableWidth - (columns - 1) * 8) / columns); // Account for gaps
                            const buttonHeight = Math.floor(availableHeight * 0.9 / totalRows); // Use 90% of available height (after accounting for other content)
                            
                            debugLog('Portrait mode - applying dimensions to', allTimeSlots.length, 'time slots');
                            debugLog('Container width:', containerWidth, 'Available width:', availableWidth);
                            debugLog('Columns:', columns, 'Button width:', buttonWidth);
                            debugLog('Button dimensions:', buttonWidth + 'x' + Math.max(60, buttonHeight));
                            
                            // Ensure the grid containers are set to 4 columns
                            const morningSlotsContainer = document.querySelector('#morningSlots');
                            const afternoonSlotsContainer = document.querySelector('#afternoonSlots');
                            if (morningSlotsContainer) {
                                morningSlotsContainer.style.gridTemplateColumns = 'repeat(4, 1fr)';
                                morningSlotsContainer.style.gap = '8px';
                            }
                            if (afternoonSlotsContainer) {
                                afternoonSlotsContainer.style.gridTemplateColumns = 'repeat(4, 1fr)';
                                afternoonSlotsContainer.style.gap = '8px';
                            }
                            
                            allTimeSlots.forEach((slot, index) => {
                                slot.style.width = buttonWidth + 'px';
                                slot.style.height = Math.max(60, buttonHeight) + 'px';
                                slot.style.minHeight = Math.max(60, buttonHeight) + 'px';
                                slot.style.boxSizing = 'border-box';
                                slot.style.flexShrink = '0';
                                
                                // Ensure the time text is visible
                                const timeText = slot.querySelector('.time-text');
                                if (timeText) {
                                    timeText.style.display = 'block';
                                    timeText.style.visibility = 'visible';
                                    timeText.style.opacity = '1';
                                    timeText.style.textAlign = 'center';
                                    timeText.style.lineHeight = '1.2';
                                    timeText.style.padding = '5px';
                                    timeText.style.fontSize = '0.9rem';
                                    timeText.style.fontWeight = '600';
                                    
                                    // Debug: Log first few slots
                                    if (index < 5) {
                                        debugLog(`Slot ${index}: ${slot.dataset.time} - Text: "${timeText.textContent}" - Visible: ${timeText.style.display}`);
                                    }
                                } else {
                                    debugLog(`ERROR: No time-text found in slot ${index} (${slot.dataset.time})`);
                                }
                            });
                        }
                    }
                }
            }
            
            // Direct fixes will be handled by the proper initialization flow
            
            // Initialize device ID
            getOrCreateDeviceId();
            // Single click handler to avoid conflicts
            document.addEventListener('click', function(e) {
                debugLog('Click detected on:', e.target.tagName, e.target.className);
                
                // Check if clicked element or its parent is a time slot
                let timeSlot = e.target.closest('.time-slot');
                if (!timeSlot && e.target.classList.contains('time-slot')) {
                    timeSlot = e.target;
                }
                
                if (timeSlot) {
                    e.preventDefault();
                    e.stopPropagation();
                    const time = timeSlot.getAttribute('data-time');
                    debugLog('Time slot clicked:', time);
                    handleSlotClick(time);
                } else {
                    debugLog('Clicked outside time slot');
                }
            });
            
            // Track touch interactions
            let touchStartElement = null;
            let hasMoved = false;

            document.body.addEventListener('touchstart', function(e) {
                touchStartElement = e.target.closest('.time-slot');
                hasMoved = false;
                // Don't prevent default - allow scrolling even on time slots
            }, { passive: true });

            document.body.addEventListener('touchmove', function(e) {
                if (touchStartElement) {
                    const currentElement = document.elementFromPoint(
                        e.touches[0].clientX,
                        e.touches[0].clientY
                    );
                    if (currentElement && !touchStartElement.contains(currentElement)) {
                        hasMoved = true;
                    }
                }
            });

            document.body.addEventListener('touchend', function(e) {
                if (touchStartElement && !hasMoved) {
                    // Small delay to allow scroll to complete first
                    setTimeout(() => {
                        if (touchStartElement && !hasMoved) {
                    const time = touchStartElement.dataset.time;
                            debugLog('Slot tapped (not scrolled):', time);
                    handleSlotClick(time);
                        }
                    }, 50); // 50ms delay to distinguish tap from scroll
                }
                touchStartElement = null;
                hasMoved = false;
            }, { passive: true });
            
            // Check if time slots exist immediately
            const timeSlots = document.querySelectorAll('.time-slot');
            timeSlots.forEach((slot, index) => {
                // Time slots found and ready
            });
            
            // Start loading bookings immediately, even before layout
            const loadStartTime = Date.now();
            
            // Load bookings for desktop
            if (!isMobile) {
            loadBookings(currentDate).then(() => {
                    const loadEndTime = Date.now();
                    // Force immediate display update after booking load
                    setTimeout(() => {
                        updateTimeSlotsImmediate();
                        updateTimeVisualization(); // Update time visualization after booking states are applied
                    }, 50);
            }).catch(error => {
                console.error('Initial booking load error:', error);
            });
            }
            
            
            // Simple initialization - back to working approach
            
            setTimeout(function() {
                isInitializing = true; // Set flag to prevent other calls
                try {
                    // Run layout detection with mobile-specific timing
                    detectScreenSize();
                    
                    // Update browser config
                    updateBrowserConfig();
                    
                    // Portrait fixes will be handled by applyContainerSizing for portrait mode
                    
                    // Clear initialization flag after a short delay
                    setTimeout(() => {
                        isInitializing = false; // Clear flag after initialization is complete
                        
                        // Mobile-specific additional layout check
                        // Removed multiple detectScreenSize calls to prevent re-adjustments
                        // if (isMobile) {
                        //     debugLog('Mobile: Running additional layout check...');
                        //     setTimeout(() => {
                        //         detectScreenSize();
                        //     }, 200);
                        //     setTimeout(() => {
                        //         detectScreenSize();
                        //     }, 500);
                        // }
                    }, 500);
                    
                    debugLog('Initialization completed');
                } catch (error) {
                    console.error('Initialization error:', error);
                    isInitializing = false; // Clear flag on error
                }
            }, initDelay); // Mobile-specific delay for viewport stability
        });

        // Auto-refresh functionality
        function startAutoRefresh() {
            // Reduced frequency since we have real-time WebSocket updates
            // This is now just a backup/fallback mechanism
            autoRefreshInterval = setInterval(function() {
                if (isMobile) {
                    loadBookingsMobile(currentDate);
                } else {
                loadBookings(currentDate);
                }
            }, 30000); // 30 seconds - much less frequent with WebSocket updates
        }


        function stopAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
                debugLog('Auto-refresh stopped');
            }
        }

        // Start auto-refresh when page loads
        setTimeout(function() {
            startAutoRefresh();
            startTimeVisualization();
            debugLog('Auto-refresh started (every 30 seconds - WebSocket provides real-time updates)');
        }, 2000); // Start after 2 seconds to let initial load complete

        // Pause auto-refresh when user is interacting with modals
        function pauseAutoRefresh() {
            stopAutoRefresh();
            debugLog('Auto-refresh paused (modal open)');
        }

        function resumeAutoRefresh() {
            startAutoRefresh();
            debugLog('Auto-refresh resumed');
        }


        // Function to check for passed slots and extract them to CSV
        function checkAndExtractPassedSlots(currentTime, currentDate) {
            // Check all booked slots to see if they have fully passed
            Object.keys(bookings).forEach(slotKey => {
                try {
                    // Parse slot key (format: "YYYY-MM-DD_HH:MM")
                    const [dateStr, timeStr] = slotKey.split('_');
                    
                    // Only check slots for the current date
                    if (dateStr !== currentDate) return;
                    
                    // Parse slot time
                    const [hours, minutes] = timeStr.split(':').map(Number);
                    const slotTime = hours * 60 + minutes;
                    const slotEndTime = slotTime + 15; // 15-minute slots
                    
                    // Check if slot has fully passed
                    if (currentTime >= slotEndTime) {
                        // Extract this booking to CSV
                        extractPassedBookingToCSV(slotKey, bookings[slotKey]);
                    }
                } catch (error) {
                    console.error('Error checking slot for extraction:', slotKey, error);
                }
            });
        }

        // Function to extract a passed booking to CSV
        function extractPassedBookingToCSV(slotKey, booking) {
            fetch('/extract_booking', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    slot_key: slotKey,
                    reason: 'time_passed'
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    debugLog(`Extracted passed booking ${slotKey} to ${data.filename}`);
                    // Remove the booking from local memory after successful extraction
                    delete bookings[slotKey];
                } else {
                    console.error('Failed to extract booking:', data.error);
                }
            })
            .catch(error => {
                console.error('Error extracting passed booking:', error);
            });
        }

        // Time visualization system
        function startTimeVisualization() {
            // Update time visualization every minute
            timeUpdateInterval = setInterval(updateTimeVisualization, 60000);
            // Also update immediately
            updateTimeVisualization();
            debugLog('Time visualization started (updating every minute)');
        }

        function stopTimeVisualization() {
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
                timeUpdateInterval = null;
                debugLog('Time visualization stopped');
            }
        }

        function updateTimeVisualization() {
            // Get server time instead of client time with cache-busting
            const timestamp = new Date().getTime();
            debugLog('updateTimeVisualization called, currentDate:', currentDate);
            fetch(`/get_current_time?_t=${timestamp}`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        const currentTime = data.time.total_minutes; // Server time in minutes since midnight
                        const serverDate = data.time.iso_string.split('T')[0]; // Server date
                        
                        debugLog('Time data received - currentTime:', currentTime, 'serverDate:', serverDate, 'currentDate:', currentDate);
                        
                        // Only show time visualization for today's date (server date)
                        if (currentDate !== serverDate) {
                            // Clear all time indicators if not viewing today
                            debugLog('Not viewing today - clearing time visualization');
                            clearTimeVisualization();
                            return;
                        }
                        
                        debugLog('Applying time visualization for today');

                        // Check for passed slots and extract them to CSV
                        checkAndExtractPassedSlots(currentTime, serverDate);

                        const slots = document.querySelectorAll('.time-slot');
                        slots.forEach(slot => {
                            const timeStr = slot.dataset.time;
                            if (!timeStr) return;

                            // Parse slot time (e.g., "09:00" -> 540 minutes)
                            const [hours, minutes] = timeStr.split(':').map(Number);
                            const slotTime = hours * 60 + minutes;
                            const slotEndTime = slotTime + 15; // 15-minute slots

                            // Remove existing time classes
                            slot.classList.remove('time-past', 'time-current', 'time-future');
                            slot.style.background = '';
                            slot.style.backgroundImage = '';

                            if (currentTime >= slotEndTime) {
                                // Past slot - completely grey
                                slot.classList.add('time-past');
                                // Add admin-enabled class if in admin mode
                                if (isAdminSession) {
                                    slot.classList.add('admin-enabled');
                                } else {
                                    slot.classList.remove('admin-enabled');
                                }
                            } else if (currentTime >= slotTime && currentTime < slotEndTime) {
                                // Current slot - partially grey based on progress
                                slot.classList.add('time-current');
                                const progress = (currentTime - slotTime) / 15; // 0 to 1
                                updateCurrentSlotVisualization(slot, progress);
                                // Current slot is always bookable, no admin class needed
                                slot.classList.remove('admin-enabled');
                            } else {
                                // Future slot - normal colors
                                slot.classList.add('time-future');
                                slot.classList.remove('admin-enabled');
                            }
                        });
                        
                        debugLog(`Time visualization updated - Server time: ${data.time.hours}:${data.time.minutes.toString().padStart(2, '0')}`);
                    }
                })
                .catch(error => {
                    console.error('Error getting server time:', error);
                    // Fallback to client time if server fails
                    const now = new Date();
                    const currentTime = now.getHours() * 60 + now.getMinutes();
                    debugLog('Falling back to client time:', currentTime);
                });
        }

        function updateCurrentSlotVisualization(slot, progress) {
            // Create gradient effect: grey (past) to normal color (future)
            const timeStr = slot.dataset.time;
            const isBooked = slot.classList.contains('booked') || (bookings[timeStr] && bookings[timeStr].device_id);
            const isAvailable = slot.classList.contains('available') || (!bookings[timeStr]);
            
            if (isBooked) {
                // Booked slot: grey to light red gradient (matching booked slot style)
                slot.style.background = `linear-gradient(to right, 
                    #d1d5db ${progress * 100}%, 
                    #fef2f2 ${progress * 100}%)`;
            } else if (isAvailable) {
                // Available slot: grey to light blue gradient (matching available slot style)
                slot.style.background = `linear-gradient(to right, 
                    #d1d5db ${progress * 100}%, 
                    #f0f9ff ${progress * 100}%)`;
            } else {
                // Default slot: grey to default color gradient
                slot.style.background = `linear-gradient(to right, 
                    #d1d5db ${progress * 100}%, 
                    #6b7280 ${progress * 100}%)`;
            }
        }

        function clearTimeVisualization() {
            const slots = document.querySelectorAll('.time-slot');
            slots.forEach(slot => {
                slot.classList.remove('time-past', 'time-current', 'time-future', 'admin-enabled');
                slot.style.background = '';
                slot.style.backgroundImage = '';
            });
        }

        // Function to update browser configuration display
        function updateBrowserConfig() {
            const configElement = document.getElementById('browserConfig');
            const isLandscape = window.matchMedia('(orientation: landscape)').matches;
            configElement.textContent = 'Current Config: ' + (isLandscape ? 'Landscape' : 'Portrait');
        }

        // Re-detect on window resize - DISABLED for portrait mode to prevent re-calculations
        window.addEventListener('resize', function() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            // Only recalculate for landscape mode, not portrait
            if (width > height) {
                setTimeout(() => {
                    detectScreenSize();
                    updateBrowserConfig();
                }, 100); // Debounce resize events
            } else {
                debugLog('Resize detected in portrait mode - skipping recalculation to prevent layout changes');
            }
        });
        
        // Mobile-specific scroll handler to fix layout issues - DISABLED to prevent multiple re-adjustments
        // let scrollTimeout;
        // window.addEventListener('scroll', function() {
        //     clearTimeout(scrollTimeout);
        //     scrollTimeout = setTimeout(() => {
        //         debugLog('Scroll detected - recalculating layout');
        //         detectScreenSize();
        //     }, 150);
        // });

        // Re-detect on orientation change - DISABLED for portrait mode to prevent re-calculations
        window.addEventListener('orientationchange', function() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            // Only recalculate when switching TO landscape mode, not when staying in portrait
            if (width > height) {
                setTimeout(() => {
                    detectScreenSize();
                    debugLog('Orientation changed to landscape - recalculating');
                }, 300);
            } else {
                debugLog('Orientation change in portrait mode - skipping recalculation to prevent layout changes');
                // Still apply CSS fixes but don't recalculate layout
                setTimeout(() => {
                    applyPortraitCSS();
                }, 100);
            }
        });
        
        // Force refresh time slot dimensions on any layout change
        function refreshTimeSlotDimensions() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            if (width > height) {
                setTimeout(() => {
                    adjustLandscapeLayout(width, height);
                }, 200);
            }
        }
        
        // Additional event listeners for time slot refresh - DISABLED for portrait mode to prevent re-calculations
        window.addEventListener('load', function() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            if (width > height) {
                refreshTimeSlotDimensions();
            } else {
                debugLog('Load event in portrait mode - skipping time slot refresh to prevent layout changes');
            }
        });
        // Removed duplicate DOMContentLoaded listener - consolidated into main one

        function selectDate(date, element) {
            // Update active tab
            document.querySelectorAll('.date-tab').forEach(tab => tab.classList.remove('active'));
            element.classList.add('active');
            
            // Leave old date room and join new date room
            if (currentDate !== date) {
                leaveDateRoom(currentDate);
                currentDate = date;
                joinDateRoom(currentDate);
            }
            
            if (isMobile) {
                loadBookingsMobile(date);
            } else {
            loadBookings(date);
            }
        }

        // Simple cache for booking data
        const bookingCache = new Map();
        const CACHE_DURATION = 2000; // 2 seconds cache
        
        // Simple browser detection - back to working approach
        
        // Mobile-optimized loading using POST with form data
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Mobile-specific loading function
        function loadBookingsMobile(date) {
            const formData = new FormData();
            formData.append('date', date);
            
            return fetch('/get_bookings', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    bookings = data.bookings;
                    updateBookingsFromData(data);
                }
                return data;
            })
            .catch(error => {
                console.error('Mobile loading error:', error);
                return {success: false, error: error};
            });
        }
        
        if (isMobile) {
            // Start mobile loading immediately
            setTimeout(() => {
                loadBookingsMobile(currentDate);
            }, 100);
        }
        

        function loadBookings(date) {
            
            return new Promise((resolve, reject) => {
                try {
                    // Check cache first
                    const cacheKey = date;
                    const cached = bookingCache.get(cacheKey);
                    const now = Date.now();
                    
                    if (cached && (now - cached.timestamp) < CACHE_DURATION) {
                        debugLog('Using cached booking data for', date);
                        // Immediately update display without waiting
                        updateBookingsFromData(cached.data);
                        resolve(cached.data);
                        return;
                    }
                    
                    // Don't show loading spinner for auto-refresh to avoid flashing
                    const isAutoRefresh = !document.querySelector('.loading-spinner');
                    
                    if (!isAutoRefresh) {
                        showLoading(true);
                    }
                    
                    // Add timestamp to prevent duplicate requests
                    const requestId = `${date}_${now}`;
                    const fetchStart = Date.now();
                    debugLog('Fetching fresh booking data for', date, 'Request ID:', requestId);
                    
                    fetch(`/get_bookings?date=${date}&_t=${now}`)
                        .then(response => {
                            const fetchEnd = Date.now();
                            debugLog('Fetch response received in', fetchEnd - fetchStart, 'ms');
                            if (!response.ok) {
                                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                            }
                            return response.json();
                        })
                        .then(data => {
                            const dataProcessEnd = Date.now();
                            debugLog('Data processing completed in', dataProcessEnd - fetchStart, 'ms');
                            
                            if (data.success) {
                                // Cache the data
                                bookingCache.set(cacheKey, {
                                    data: data,
                                    timestamp: now
                                });
                                
                                // Update display
                                const displayStart = Date.now();
                                updateBookingsFromData(data);
                                const displayEnd = Date.now();
                                debugLog('Display update completed in', displayEnd - displayStart, 'ms');
                            } else {
                                console.error('Failed to load bookings:', data.message);
                            }
                            
                            if (!isAutoRefresh) {
                                showLoading(false);
                            }
                            resolve(data);
                        })
                        .catch(error => {
                            console.error('Error loading bookings:', error);
                            if (!isAutoRefresh) {
                                showLoading(false);
                            }
                            reject(error);
                        });
                } catch (error) {
                    console.error('Error in loadBookings:', error);
                    if (!isAutoRefresh) {
                        showLoading(false);
                    }
                    reject(error);
                }
            });
        }
        
        function updateBookingsFromData(data) {
            if (data.success) {
                debugLog('updateBookingsFromData called with:', data.bookings);
                const newBookings = data.bookings;
                const now = Date.now();
                
                // Always update display for initial load or if bookings exist
                const isInitialLoad = !bookings || Object.keys(bookings).length === 0;
                const hasBookings = newBookings && Object.keys(newBookings).length > 0;
                const hasChanges = compareBookings(bookings, newBookings);
                
                if (isInitialLoad || hasChanges || hasBookings) {
                    debugLog('Updating display - Initial:', isInitialLoad, 'Changes:', hasChanges, 'HasBookings:', hasBookings);
                    bookings = newBookings;
                    
                    // Force immediate update without waiting for animations
                    updateTimeSlotsImmediate();
                    
                    // Mobile-specific additional update to ensure display
                    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    if (isMobile) {
                        debugLog('Mobile: Additional booking display update');
                        setTimeout(() => {
                            updateTimeSlotsImmediate();
                            // Update time visualization after slot classes are updated
                            updateTimeVisualization();
                        }, 100);
                    } else {
                        // For desktop, update time visualization after slot classes are updated
                        setTimeout(() => {
                            updateTimeVisualization();
                        }, 50);
                    }
                    
                    // Then apply smooth transitions
                    setTimeout(() => {
                        updateTimeSlotsSmooth();
                    }, 10);
                } else {
                    debugLog('No booking changes detected');
                }
                
                // Preload adjacent dates for faster switching
                preloadAdjacentDates(data.date);

                // Highlight newly booked slots for everyone:
                // 1) Changed from available->booked in this update
                // 2) Or booked_at within last 5s
                const slots = document.querySelectorAll('.time-slot');
                slots.forEach(slot => {
                    const timeStr = slot.dataset.time;
                    const prevHad = bookings && bookings[timeStr] && bookings[timeStr].device_id;
                    const nowHas = newBookings && newBookings[timeStr] && newBookings[timeStr].device_id;
                    let isNewlyBooked = !prevHad && !!nowHas;
                    if (!isNewlyBooked && nowHas) {
                        const bookedAt = newBookings[timeStr].booked_at;
                        if (bookedAt) {
                            const ts = Date.parse(bookedAt);
                            if (!isNaN(ts) && (now - ts) <= 5000) {
                                isNewlyBooked = true;
                            }
                        }
                    }
                    if (isNewlyBooked) {
                        slot.classList.add('just-booked');
                        setTimeout(() => slot.classList.remove('just-booked'), 5000);
                    }
                });
            }
        }
        
        function updateTimeSlotsImmediate() {
            debugLog('updateTimeSlotsImmediate called');
            const slots = document.querySelectorAll('.time-slot');
            debugLog('Found slots for immediate update:', slots.length);
            
            // Detect mobile and use appropriate update method
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            if (isMobile) {
                debugLog('Mobile device detected - using mobile-optimized update');
                updateSlotsMobile(slots);
            } else {
                debugLog('Desktop device detected - using desktop update');
                updateSlotsDesktop(slots);
            }
        }
        
        function updateSlotsMobile(slots) {
            debugLog('Mobile-optimized slot update - immediate processing');
            // Process all slots immediately for faster mobile loading
            slots.forEach(slot => {
                    const time = slot.dataset.time;
                    
                    if (bookings[time]) {
                        // Mobile-optimized: Direct style manipulation
                        slot.style.transition = 'none'; // Disable transitions for speed
                        slot.classList.remove('available');
                        slot.classList.add('booked');
                        
                        
                        // Check if this booking was made by the current device
                        if (bookings[time].device_id === deviceId) {
                            slot.classList.add('my-device');
                        } else {
                            slot.classList.remove('my-device');
                        }
                        
                        const bookedText = slot.querySelector('.booked-text');
                        const rawUsername = bookings[time].username || 'Booked';
                        const username = sanitizeUsernameForDisplay(rawUsername);
                        
                        // Check if text would overflow and hide name if needed
                        if (shouldHideBookerName(slot, username)) {
                            bookedText.textContent = '';
                            bookedText.style.display = 'none';
                            bookedText.classList.remove('cancel-hint', 'empty-username');
                        } else {
                            bookedText.textContent = username;
                            bookedText.style.display = 'block';
                            bookedText.classList.add('cancel-hint');
                            
                            // Add italic style for empty usernames
                            if (!bookings[time].username) {
                                bookedText.classList.add('empty-username');
                            } else {
                                bookedText.classList.remove('empty-username');
                            }
                        }
                    } else {
                        // Mobile-optimized: Direct style manipulation
                        slot.style.transition = 'none'; // Disable transitions for speed
                        slot.classList.remove('booked', 'my-device');
                        slot.classList.add('available');
                        
                        
                        const bookedText = slot.querySelector('.booked-text');
                        bookedText.style.display = 'none';
                        bookedText.classList.remove('cancel-hint', 'empty-username');
                    }
            });
            
            debugLog('Mobile update completed - immediate processing');
        }
        
        function updateSlotsDesktop(slots) {
            debugLog('Desktop slot update - processing', slots.length, 'slots');
            slots.forEach(slot => {
                const time = slot.dataset.time;
                debugLog(`Processing slot ${time}, booking exists:`, !!bookings[time]);
                
                if (bookings[time]) {
                    // Immediate update to booked state
                    debugLog(`Setting slot ${time} to booked state`);
                    slot.classList.remove('available');
                    slot.classList.add('booked');
                    
                    
                    // Check if this booking was made by the current device
                    if (bookings[time].device_id === deviceId) {
                        slot.classList.add('my-device');
                    } else {
                        slot.classList.remove('my-device');
                    }
                    
                    const bookedText = slot.querySelector('.booked-text');
                    const rawUsername = bookings[time].username || 'Booked';
                    const username = sanitizeUsernameForDisplay(rawUsername);
                    
                    // Check if text would overflow and hide name if needed
                    if (shouldHideBookerName(slot, username)) {
                        bookedText.textContent = '';
                        bookedText.style.display = 'none';
                        bookedText.classList.remove('cancel-hint', 'empty-username');
                    } else {
                        bookedText.textContent = username;
                        bookedText.style.display = 'block';
                        bookedText.classList.add('cancel-hint');
                        
                        // Add italic style for empty usernames
                        if (!bookings[time].username) {
                            bookedText.classList.add('empty-username');
                        } else {
                            bookedText.classList.remove('empty-username');
                        }
                    }
                } else {
                    // Immediate update to available state
                    debugLog(`Setting slot ${time} to available state`);
                    slot.classList.remove('booked', 'my-device');
                    slot.classList.add('available');
                    
                    
                    const bookedText = slot.querySelector('.booked-text');
                    if (bookedText) {
                        bookedText.style.display = 'none';
                        bookedText.classList.remove('cancel-hint', 'empty-username');
                    }
                }
            });
            debugLog('Desktop update completed');
        }
        
        function shouldHideBookerName(slot, username) {
            // Hide booker name if not in admin mode
            if (!isAdminSession) {
                debugLog(`Hiding booker name for slot ${slot.dataset.time}: not in admin mode`);
                return true;
            }
            
            // Get the slot dimensions
            const slotRect = slot.getBoundingClientRect();
            const slotHeight = slotRect.height;
            
            // Get the time text element
            const timeText = slot.querySelector('.time-text');
            if (!timeText) return true; // If no time text, hide name
            
            // Calculate available space for the booker name
            // Reserve space for time text + padding + margins
            const timeTextHeight = timeText.offsetHeight;
            const padding = 30; // Total padding (15px top + 15px bottom)
            const margin = 10; // Space between time and name
            const minNameHeight = 20; // Minimum height needed for name text
            
            const availableHeight = slotHeight - timeTextHeight - padding - margin;
            
            // Hide name if there's not enough space
            if (availableHeight < minNameHeight) {
                debugLog(`Hiding booker name for slot ${slot.dataset.time}: height=${slotHeight}px, available=${availableHeight}px`);
                return true;
            }
            
            // Also hide if slot is very narrow (width < 100px)
            const slotWidth = slotRect.width;
            if (slotWidth < 100) {
                debugLog(`Hiding booker name for slot ${slot.dataset.time}: width=${slotWidth}px too narrow`);
                return true;
            }
            
            return false;
        }
        
        function preloadAdjacentDates(currentDate) {
            // Preload tomorrow and day after for faster date switching
            const dates = ['today', 'tomorrow', 'day_after'];
            const currentIndex = dates.indexOf(currentDate);
            
            if (currentIndex !== -1) {
                // Preload next date
                if (currentIndex < dates.length - 1) {
                    const nextDate = dates[currentIndex + 1];
                    if (!bookingCache.has(nextDate)) {
                        debugLog('Preloading next date:', nextDate);
                        loadBookings(nextDate).catch(error => {
                            debugLog('Preload failed for', nextDate, error);
                        });
                    }
                }
                
                // Preload previous date
                if (currentIndex > 0) {
                    const prevDate = dates[currentIndex - 1];
                    if (!bookingCache.has(prevDate)) {
                        debugLog('Preloading previous date:', prevDate);
                        loadBookings(prevDate).catch(error => {
                            debugLog('Preload failed for', prevDate, error);
                        });
                    }
                }
            }
        }

        // Compare bookings to detect changes
        function compareBookings(oldBookings, newBookings) {
            const oldKeys = Object.keys(oldBookings || {});
            const newKeys = Object.keys(newBookings || {});
            
            // Different number of bookings
            if (oldKeys.length !== newKeys.length) {
                return true;
            }
            
            // Check if any booking changed
            for (let time of oldKeys) {
                if (!newBookings[time] || oldBookings[time].username !== newBookings[time].username) {
                    return true;
                }
            }
            
            // Check if any new booking was added
            for (let time of newKeys) {
                if (!oldBookings[time]) {
                    return true;
                }
            }
            
            return false;
        }

        function updateTimeSlotsSmooth() {
            const slots = document.querySelectorAll('.time-slot');
            slots.forEach(slot => {
                const time = slot.dataset.time;
                const slotKey = `${currentDate}_${time}`;
                
                if (bookings[time]) {
                    // Smooth transition to booked state
                    if (!slot.classList.contains('booked')) {
                        slot.style.transition = 'all 0.3s ease';
                        slot.classList.remove('available');
                        slot.classList.add('booked');
                        
                        // Check if this booking was made by the current device
                        if (bookings[time].device_id === deviceId) {
                            slot.classList.add('my-device');
                        } else {
                            slot.classList.remove('my-device');
                        }
                        
                        const bookedText = slot.querySelector('.booked-text');
                        const rawUsername = bookings[time].username || 'Booked';
                        const username = sanitizeUsernameForDisplay(rawUsername);
                        
                        // Check if text would overflow and hide name if needed
                        if (shouldHideBookerName(slot, username)) {
                            bookedText.textContent = '';
                            bookedText.style.display = 'none';
                            bookedText.classList.remove('cancel-hint', 'empty-username');
                        } else {
                            bookedText.textContent = username;
                            bookedText.style.display = 'block';
                            bookedText.classList.add('cancel-hint');
                            
                            // Add italic style for empty usernames
                            if (!bookings[time].username) {
                                bookedText.classList.add('empty-username');
                            } else {
                                bookedText.classList.remove('empty-username');
                            }
                        }
                        
                        // Remove transition after animation
                        setTimeout(() => {
                            slot.style.transition = '';
                        }, 300);
                    }
                } else {
                    // Smooth transition to available state
                    if (slot.classList.contains('booked')) {
                        slot.style.transition = 'all 0.3s ease';
                        slot.classList.remove('booked', 'my-device');
                        slot.classList.add('available');
                        slot.querySelector('.booked-text').textContent = 'Available';
                        slot.querySelector('.booked-text').style.display = 'none';
                        slot.querySelector('.booked-text').classList.remove('cancel-hint');
                        
                        // Remove transition after animation
                        setTimeout(() => {
                            slot.style.transition = '';
                        }, 300);
                    }
                }
            });
        }

        function updateTimeSlots() {
            const slots = document.querySelectorAll('.time-slot');
            slots.forEach(slot => {
                const time = slot.dataset.time;
                const slotKey = `${currentDate}_${time}`;
                
                if (bookings[time]) {
                    slot.classList.remove('available');
                    slot.classList.add('booked');
                    
                    // Check if this booking was made by the current device
                    if (bookings[time].device_id === deviceId) {
                        slot.classList.add('my-device');
                    } else {
                        slot.classList.remove('my-device');
                    }
                    
                    const bookedText = slot.querySelector('.booked-text');
                    const rawUsername = bookings[time].username || 'Booked';
                    const username = sanitizeUsernameForDisplay(rawUsername);
                    bookedText.textContent = username;
                    bookedText.style.display = 'block';
                    bookedText.classList.add('cancel-hint');
                    
                    // Add italic style for empty usernames
                    if (!bookings[time].username) {
                        bookedText.classList.add('empty-username');
                    } else {
                        bookedText.classList.remove('empty-username');
                    }
                } else {
                    slot.classList.remove('booked', 'my-device');
                    slot.classList.add('available');
                    slot.querySelector('.booked-text').textContent = 'Available';
                    slot.querySelector('.booked-text').style.display = 'none';
                    slot.querySelector('.booked-text').classList.remove('cancel-hint');
                }
            });
        }

        function handleSlotClick(time) {
            debugLog('handleSlotClick called with:', time);
            currentSlot = time;
            const slot = document.querySelector(`[data-time="${time}"]`);
            
            if (!slot) {
                console.error('Slot not found for time:', time);
                return;
            }
            
            if (slot.classList.contains('booked')) {
                // If booking was made in kiosk mode, block non-admin cancellation attempts
                const timeStr = slot.dataset.time;
                const booking = bookings[timeStr];
                if (booking && booking.kiosk && !isAdminSession) {
                    showNotification('Booking made on Kiosk cannot be cancelled', 'error');
                    return;
                }
                // Check if normal user is trying to cancel a past slot booking
                if (!isAdminSession && slot.classList.contains('time-past')) {
                    showNotification('Cannot cancel past time slot bookings', 'error');
                    return;
                }
                
                // Check if this booking was made by the current device OR if user is admin
                if ((bookings[time] && bookings[time].device_id === deviceId) || isAdminSession) {
                    if (isAdminSession) {
                        // Show admin management modal
                        const adminModal = document.getElementById('adminManagementModal');
                        const bookingUser = document.getElementById('adminBookingUser');
                        const bookingDateTime = document.getElementById('adminBookingDateTime');
                        
                        const username = bookings[time] ? bookings[time].username || 'Unknown User' : 'Unknown User';
                        const dateTime = `${currentDate} ${time}`;
                        
                        // Sanitize username for display (replace inappropriate content)
                        const sanitizedUsername = sanitizeUsernameForDisplay(username);
                        
                        bookingUser.textContent = sanitizedUsername;
                        bookingDateTime.textContent = dateTime;
                        
                        adminModal.style.display = 'block';
                    } else {
                        // Show regular cancel modal for non-admin users
                        const cancelModal = document.getElementById('cancelModal');
                        cancelModal.style.display = 'block';
                    }
                    pauseAutoRefresh();
                } else {
                    // Show message that user cannot cancel other's bookings
                    showNotification('You can only cancel your own bookings', 'error');
                }
            } else {
                // Check if normal user is trying to book a past slot (but allow current slot)
                if (!isAdminSession) {
                    if (slot.classList.contains('time-past')) {
                        showNotification('Cannot book past time slots', 'error');
                        return;
                    }
                }
                
                // Show booking modal
                document.getElementById('bookingModal').style.display = 'block';
                pauseAutoRefresh();
                
                // Load saved username from localStorage (only if not in kiosk mode)
                if (!isKioskMode) {
                const savedUsername = localStorage.getItem('booking_username');
                if (savedUsername) {
                    document.getElementById('usernameInput').value = savedUsername;
                    // Show the clear button
                    document.querySelector('.clear-saved-info').style.display = 'block';
                } else {
                    // Hide the clear button if no saved username
                        document.querySelector('.clear-saved-info').style.display = 'none';
                    }
                } else {
                    // In kiosk mode, always clear the input and hide clear button
                    document.getElementById('usernameInput').value = '';
                    document.querySelector('.clear-saved-info').style.display = 'none';
                }
                
                // Reinitialize type-ahead for the modal
                initializeTypeahead();
                
                // Focus input field only in kiosk mode (for immediate interaction)
                if (isKioskMode) {
                document.getElementById('usernameInput').focus();
                }
            }
        }

        function confirmBooking() {
            const username = document.getElementById('usernameInput').value.trim();
            
            debugLog('confirmBooking called with username:', username || '(empty)');

            // Save username to localStorage for future use (only if not in kiosk mode)
            if (!isKioskMode) {
            localStorage.setItem('booking_username', username);
            }

            const headers = {
                'Content-Type': 'application/json'
            };
            const csrfToken = getCSRFToken();
            if (csrfToken) {
                headers['X-CSRFToken'] = csrfToken;
            }
            
            fetch('/book', {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                    date: currentDate,
                    time: currentSlot,
                    username: username || '', // Leave blank if empty
                    device_id: deviceId, // Include device ID for tracking
                    kiosk: !!isKioskMode
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    closeModal();
                    if (isMobile) {
                        loadBookingsMobile(currentDate);
                    } else {
                    loadBookings(currentDate);
                    }
                    // Update the slot to booked state
                    const bookedSlot = document.querySelector(`[data-time="${currentSlot}"]`);
                    if (bookedSlot) {
                        // Update to booked state
                        bookedSlot.classList.remove('available');
                        bookedSlot.classList.add('booked');
                        
                        // Add transient highlight
                        bookedSlot.classList.add('just-booked');
                        setTimeout(() => bookedSlot.classList.remove('just-booked'), 5000);
                        
                        // Update the booked text
                        const bookedText = bookedSlot.querySelector('.booked-text');
                        if (bookedText) {
                            bookedText.textContent = username || 'Booked';
                            bookedText.style.display = 'block';
                        }
                    }
                    const message = username ? 'Booking confirmed!' : 'Booking confirmed! (No name provided)';
                    showNotification(message, 'success');
                } else {
                    alert(data.message);
                }
            })
            .catch(error => {
                console.error('Error booking slot:', error);
                alert('An error occurred while booking. Please try again.');
            });
        }

        function confirmCancellation() {
            const headers = {
                'Content-Type': 'application/json'
            };
            const csrfToken = getCSRFToken();
            if (csrfToken) {
                headers['X-CSRFToken'] = csrfToken;
            }
            
            fetch('/cancel', {
                method: 'POST',
                headers: headers,
                body: JSON.stringify({
                    date: currentDate,
                    time: currentSlot,
                    device_id: deviceId, // Include device ID for verification
                    is_admin: isAdminSession // Include admin status
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    closeModal();
                    
                    // Clear cache to force fresh data load
                    bookingCache.clear();
                    
                    // Remove the specific booking from local memory immediately
                    const slotKey = `${currentDate}_${currentSlot}`;
                    delete bookings[slotKey];
                    
                    // Force immediate visual update
                    updateTimeSlotsImmediate();
                    
                    // Directly update the specific slot that was cancelled
                    const specificSlot = document.querySelector(`[data-time="${currentSlot}"]`);
                    if (specificSlot) {
                        debugLog('Directly updating cancelled slot:', currentSlot);
                        specificSlot.classList.remove('booked', 'my-device');
                        specificSlot.classList.add('available');
                        
                        // Mark as recently updated to prevent gradient override
                        specificSlot.dataset.lastUpdate = Date.now().toString();
                        
                        const bookedText = specificSlot.querySelector('.booked-text');
                        if (bookedText) {
                            bookedText.style.display = 'none';
                            bookedText.classList.remove('cancel-hint', 'empty-username');
                        }
                    }
                    
                    // Then load fresh data
                    if (isMobile) {
                        loadBookingsMobile(currentDate);
                    } else {
                        loadBookings(currentDate);
                    }
                    
                    // Show different message based on admin status
                    if (isAdminSession) {
                        showNotification('❌ Booking cancelled successfully.', 'success');
                    } else {
                        showNotification('Booking cancelled!', 'success');
                    }
                } else {
                    alert(data.message);
                }
            })
            .catch(error => {
                console.error('Error cancelling booking:', error);
                alert('An error occurred while cancelling. Please try again.');
            });
        }

        function markCaseCompleted() {
            // Use the same cancellation logic but with different success message
            const headers = {
                'Content-Type': 'application/json'
            };
            const csrfToken = getCSRFToken();
            if (csrfToken) {
                headers['X-CSRFToken'] = csrfToken;
            }
            
            fetch('/cancel', {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        date: currentDate,
                        time: currentSlot,
                        device_id: deviceId,
                        is_admin: isAdminSession,
                        reason: 'completed'  // Mark as completed for CSV extraction
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        closeModal();
                        
                        // Clear cache to force fresh data load
                        bookingCache.clear();
                        
                        // Remove the specific booking from local memory immediately
                        const slotKey = `${currentDate}_${currentSlot}`;
                        debugLog('Removing booking from local memory:', slotKey);
                        delete bookings[slotKey];
                        debugLog('Current bookings after deletion:', bookings);
                        
                        // Force immediate visual update for the specific slot
                        debugLog('Calling updateTimeSlotsImmediate...');
                        updateTimeSlotsImmediate();
                        
                        // Directly update the specific slot that was completed
                        const specificSlot = document.querySelector(`[data-time="${currentSlot}"]`);
                        if (specificSlot) {
                            debugLog('Directly updating specific slot:', currentSlot);
                            specificSlot.classList.remove('booked', 'my-device');
                            specificSlot.classList.add('available');
                            
                            // Mark as recently updated to prevent gradient override
                            specificSlot.dataset.lastUpdate = Date.now().toString();
                            
                            const bookedText = specificSlot.querySelector('.booked-text');
                            if (bookedText) {
                                bookedText.style.display = 'none';
                                bookedText.classList.remove('cancel-hint', 'empty-username');
                            }
                            debugLog('Direct slot update completed');
                        } else {
                            debugLog('Specific slot not found:', currentSlot);
                        }
                        
                        // Also call updateTimeVisualization to ensure time-based styling is correct
                        updateTimeVisualization();
                        
                        // Then load fresh data
                        if (isMobile) {
                            loadBookingsMobile(currentDate);
                        } else {
                            loadBookings(currentDate);
                        }
                        
                        showNotification('✅ Case marked as completed. Slot is now available for booking.', 'success');
                    } else {
                        alert(data.message);
                    }
                })
                .catch(error => {
                    console.error('Error marking case as completed:', error);
                    alert('An error occurred while marking case as completed. Please try again.');
                });
        }

        function showAdminCancelConfirmation() {
            // Close the admin management modal
            document.getElementById('adminManagementModal').style.display = 'none';
            
            // Show the admin cancel confirmation modal
            document.getElementById('adminCancelModal').style.display = 'block';
        }

        function showAdminCaseCompletedConfirmation() {
            // Close the admin management modal
            document.getElementById('adminManagementModal').style.display = 'none';
            
            // Show the admin case completed confirmation modal
            document.getElementById('adminCaseCompletedModal').style.display = 'block';
        }

        function closeModal() {
            document.getElementById('bookingModal').style.display = 'none';
            document.getElementById('cancelModal').style.display = 'none';
            document.getElementById('adminManagementModal').style.display = 'none';
            document.getElementById('adminCancelModal').style.display = 'none';
            document.getElementById('adminCaseCompletedModal').style.display = 'none';
            document.getElementById('adminModal').style.display = 'none';
            document.getElementById('usernameInput').value = '';
            document.getElementById('adminPasswordInput').value = '';
            
            // Clean up admin password event listener
            if (adminPasswordKeypressHandler) {
                const passwordInput = document.getElementById('adminPasswordInput');
                passwordInput.removeEventListener('keypress', adminPasswordKeypressHandler);
                adminPasswordKeypressHandler = null;
            }
            
            resumeAutoRefresh(); // Resume auto-refresh when modal closes
        }

        function clearSavedUsername() {
            // Clear the saved username from localStorage
            localStorage.removeItem('booking_username');
            
            // Clear the input field
            document.getElementById('usernameInput').value = '';
            
            // Show confirmation message
            showNotification('Saved name cleared!', 'success');
            
            // Focus on the input field
            document.getElementById('usernameInput').focus();
        }

        // Admin functionality
        // Store the keypress event listener function for cleanup
        let adminPasswordKeypressHandler = null;

        function showAdminModal() {
            if (isAdminSession) {
                // If already admin, allow to exit
                exitAdminSession();
                return;
            }
            document.getElementById('adminModal').style.display = 'block';
            updateVersionDisplay(); // Update version display when modal is shown
            pauseAutoRefresh();
            const passwordInput = document.getElementById('adminPasswordInput');
            passwordInput.focus();
            
            // Remove any existing event listener first
            if (adminPasswordKeypressHandler) {
                passwordInput.removeEventListener('keypress', adminPasswordKeypressHandler);
            }
            
            // Add Enter key event listener
            adminPasswordKeypressHandler = function(e) {
                if (e.key === 'Enter') {
                    verifyAdminPassword();
                }
            };
            passwordInput.addEventListener('keypress', adminPasswordKeypressHandler);
        }

        // Brute force protection variables
        let lastFailedAttempt = 0;
        let failedAttempts = 0;
        let isVerifyingAdmin = false; // Prevent multiple simultaneous verification requests
        let adminVerificationSuccess = false; // Track if admin verification was successful

        function verifyAdminPassword() {
            const password = document.getElementById('adminPasswordInput').value.trim();
            const now = Date.now();
            
            // Prevent multiple simultaneous verification requests
            if (isVerifyingAdmin) {
                debugLog('Admin verification already in progress, ignoring duplicate request');
                return;
            }
            
            // Check if we need to wait due to recent failed attempts
            if (now - lastFailedAttempt < 1000) {
                const remainingTime = Math.ceil((1000 - (now - lastFailedAttempt)) / 1000);
                showNotification(`Please wait ${remainingTime} second(s) before trying again`, 'error');
                return;
            }
            
            // Clear any existing notifications to prevent conflicts
            clearAllNotifications();
            
            // Reset success flag and set verification flag
            adminVerificationSuccess = false;
            isVerifyingAdmin = true;
            
            // Always verify password on server side for security
            fetch('/admin/verify', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ password: password })
            })
            .then(response => {
                debugLog('Admin verification response status:', response.status);
                debugLog('Admin verification response headers:', response.headers);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                // Check if response is JSON
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    throw new Error('Response is not JSON');
                }
                
                return response.json();
            })
            .then(data => {
                debugLog('Admin verification response data:', data);
                
                // Validate response structure
                if (typeof data !== 'object' || data === null) {
                    throw new Error('Invalid response format');
                }
                
                if (data.success === true) {
                    // Mark verification as successful
                    adminVerificationSuccess = true;
                    
                    // Reset failed attempts on successful login
                    failedAttempts = 0;
                    lastFailedAttempt = 0;
                    
                    isAdminSession = true;
                    document.getElementById('adminBtn').classList.add('admin-active');
                    updateAdminButtonText();
                    closeModal();
                    showNotification('Admin access granted! You can now cancel any booking.', 'success');
                    // Update time visualization to enable past slot booking for admin
                    updateTimeVisualization();
                    debugLog('Admin session activated');
                    // Refresh display to show booker names
                    refreshDisplay();
                } else if (data.success === false) {
                    // Record failed attempt
                    failedAttempts++;
                    lastFailedAttempt = now;
                    
                    showNotification('Invalid admin password', 'error');
                    document.getElementById('adminPasswordInput').value = '';
                    document.getElementById('adminPasswordInput').focus();
                } else {
                    throw new Error('Invalid response: missing success field');
                }
                
                // Reset verification flag
                isVerifyingAdmin = false;
            })
            .catch(error => {
                console.error('Admin verification error details:', {
                    message: error.message,
                    name: error.name,
                    stack: error.stack
                });
                
                // Reset verification flag first
                isVerifyingAdmin = false;
                
                // Don't show error notification if verification was already successful
                if (adminVerificationSuccess) {
                    debugLog('Admin verification was successful, not showing error notification');
                    return;
                }
                
                // Only show error if it's a real network/server error
                if (error.message && error.message.includes('HTTP error')) {
                    showNotification('Server error - please try again', 'error');
                } else if (error.message && error.message.includes('Response is not JSON')) {
                    showNotification('Server response error - please try again', 'error');
                } else if (error.message && error.message.includes('Invalid response')) {
                    showNotification('Server response format error - please try again', 'error');
                } else {
                    showNotification('Network error - please check your connection', 'error');
                }
            });
        }

        function exitAdminSession() {
            isAdminSession = false;
            document.getElementById('adminBtn').classList.remove('admin-active');
            updateAdminButtonText();
            showNotification('Admin session ended', 'info');
            debugLog('Admin session ended');
            // Update time visualization to disable past slot booking for normal users
            updateTimeVisualization();
            // Refresh display to hide booker names
            refreshDisplay();
        }

        function updateAdminButtonText() {
            const adminBtn = document.getElementById('adminBtn');
            const isPortrait = window.innerHeight > window.innerWidth;
            
            if (isAdminSession) {
                if (isPortrait) {
                    adminBtn.innerHTML = '<i class="fas fa-user-shield"></i>';
                } else {
                    adminBtn.innerHTML = '<i class="fas fa-user-shield"></i> Admin';
                }
            } else {
                if (isPortrait) {
                    adminBtn.innerHTML = '<i class="fas fa-user-shield"></i>';
                } else {
                    adminBtn.innerHTML = '<i class="fas fa-user-shield"></i> Admin';
                }
            }
        }

        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
        }

        // Enhanced Toast Notification System
        let notificationStack = [];

        // Bad words filter for display sanitization
        const badWords = [
            'fuck', 'shit', 'damn', 'hell', 'bitch', 'ass', 'bastard', 'whore', 'slut', 'cunt',
            'piss', 'crap', 'fucking', 'shitty', 'damned', 'bloody', 'bollocks', 'bugger', 'wanker',
            'twat', 'prick', 'dick', 'cock', 'pussy', 'tits', 'boobs', 'fag', 'faggot', 'nigger',
            'nigga', 'chink', 'gook', 'kike', 'spic', 'wetback', 'retard', 'retarded', 'moron',
            'idiot', 'stupid', 'dumb', 'fool', 'loser', 'freak', 'weirdo', 'creep', 'pervert',
            'pedophile', 'rapist', 'murderer', 'killer', 'suicide', 'kill', 'die', 'death', 'hate',
            'hater', 'racist', 'sexist', 'homophobe', 'nazi', 'hitler', 'stalin', 'terrorist',
            'bomb', 'explosive', 'weapon', 'gun', 'knife', 'sword', 'poison', 'drug', 'cocaine',
            'heroin', 'marijuana', 'weed', 'alcohol', 'drunk', 'stoned', 'high', 'overdose',
            'addict', 'junkie', 'dealer', 'pimp', 'prostitute', 'hooker', 'escort', 'stripper',
            'porn', 'pornography', 'xxx', 'adult', 'sex', 'sexual', 'nude', 'naked', 'breast',
            'penis', 'vagina', 'orgasm', 'masturbate'
        ];

        function sanitizeUsernameForDisplay(username) {
            if (!username) return 'Unknown User';
            
            let sanitized = username;
            const usernameLower = username.toLowerCase();
            
            // Check for bad words and replace with asterisks
            for (const badWord of badWords) {
                if (usernameLower.includes(badWord)) {
                    const regex = new RegExp(badWord, 'gi');
                    sanitized = sanitized.replace(regex, '*'.repeat(badWord.length));
                }
            }
            
            // If the entire name was inappropriate, show a generic message
            if (sanitized.replace(/\*/g, '').trim().length === 0) {
                return 'Inappropriate Name';
            }
            
            return sanitized;
        }

        function showNotification(message, type) {
            // Create notification element
            const notification = document.createElement('div');
            const notificationId = Date.now() + Math.random();
            
            // Determine icon based on type
            let icon = '';
            let bgColor = '';
            switch(type) {
                case 'success':
                    icon = '✓';
                    bgColor = '#10b981';
                    break;
                case 'error':
                    icon = '⚠';
                    bgColor = '#ef4444';
                    break;
                case 'info':
                    icon = 'ℹ';
                    bgColor = '#3b82f6';
                    break;
                default:
                    icon = 'ℹ';
                    bgColor = '#6b7280';
            }
            
            // Calculate position based on existing notifications - all top center
            const existingNotifications = document.querySelectorAll('.toast-notification');
            const topOffset = 20 + (existingNotifications.length * 70); // Stack vertically with 70px spacing
            
            // Apply enhanced styling
            notification.className = 'toast-notification';
            notification.setAttribute('data-notification-id', notificationId);
            notification.style.cssText = `
                position: fixed;
                top: ${topOffset}px;
                left: 50%;
                transform: translateX(-50%) translateY(-20px);
                background: ${bgColor};
                color: white;
                padding: 18px 20px;
                border-radius: 12px;
                z-index: 10000;
                font-weight: 500;
                font-size: 14px;
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
                display: flex;
                align-items: flex-start;
                justify-content: center;
                gap: 8px;
                max-width: 350px;
                min-width: 200px;
                opacity: 0;
                transition: all 0.3s ease;
                cursor: pointer;
            `;
            
            // Add icon and message
            notification.innerHTML = `
                <span style="font-size: 16px; font-weight: bold; line-height: 1.2; display: flex; align-items: flex-start; padding-top: 2px;">${icon}</span>
                <span style="line-height: 1.2; display: flex; align-items: flex-start;">${message}</span>
            `;
            
            // Add to DOM
            document.body.appendChild(notification);
            notificationStack.push({ id: notificationId, element: notification });
            
            // Check notification limit before adding new one
            checkNotificationLimit();
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(-50%) translateY(0)';
            }, 10);
            
            // Click to dismiss
            notification.addEventListener('click', () => {
                dismissNotification(notificationId);
            });
            
            // Auto dismiss after duration - ensure all notifications dismiss
            const duration = type === 'error' ? 5000 : 4000; // Increased duration for better visibility
            const timeoutId = setTimeout(() => {
                // Double-check the notification still exists before dismissing
                if (document.querySelector(`[data-notification-id="${notificationId}"]`)) {
                    dismissNotification(notificationId);
                }
            }, duration);
            
            // Store timeout ID for potential cleanup
            notification.setAttribute('data-timeout-id', timeoutId);
        }
        
        function dismissNotification(notificationId) {
            const notificationIndex = notificationStack.findIndex(n => n.id === notificationId);
            if (notificationIndex === -1) return;
            
            const notification = notificationStack[notificationIndex].element;
            
            // Clear any pending timeout
            const timeoutId = notification.getAttribute('data-timeout-id');
            if (timeoutId) {
                clearTimeout(parseInt(timeoutId));
            }
            
            // Animate out
            notification.style.opacity = '0';
            notification.style.transform = 'translateX(-50%) translateY(-20px)';
            
            // Remove after animation
            setTimeout(() => {
                if (notification && notification.parentNode) {
                    notification.remove();
                }
                
                // Remove from stack
                notificationStack.splice(notificationIndex, 1);
                
                // Reposition remaining notifications
                repositionNotifications();
            }, 300);
        }
        
        function repositionNotifications() {
            const notifications = document.querySelectorAll('.toast-notification');
            notifications.forEach((notification, index) => {
                const topOffset = 20 + (index * 70);
                notification.style.top = `${topOffset}px`;
            });
        }
        
        // Clear all notifications (safety function)
        function clearAllNotifications() {
            const notifications = document.querySelectorAll('.toast-notification');
            notifications.forEach(notification => {
                const timeoutId = notification.getAttribute('data-timeout-id');
                if (timeoutId) {
                    clearTimeout(parseInt(timeoutId));
                }
                notification.remove();
            });
            notificationStack = [];
        }
        
        // Safety mechanism: Clear old notifications if too many accumulate
        function checkNotificationLimit() {
            if (notificationStack.length > 5) {
                // Remove oldest notifications, keep only the 3 most recent
                const toRemove = notificationStack.slice(0, notificationStack.length - 3);
                toRemove.forEach(notification => {
                    dismissNotification(notification.id);
                });
            }
        }
        
        // Global function for debugging - clear all notifications
        window.clearAllNotifications = clearAllNotifications;

        // Close modals when clicking outside - REMOVED TO AVOID CONFLICTS
        // window.onclick = function(event) {
        //     const bookingModal = document.getElementById('bookingModal');
        //     const cancelModal = document.getElementById('cancelModal');
        //     
        //     if (event.target === bookingModal) {
        //         closeModal();
        //     }
        //     if (event.target === cancelModal) {
        //         closeModal();
        //     }
        // }

        // Enter key handling is now included in initializeTypeahead()

        // Type-ahead functionality for username input
        let allNames = [];
        let filteredNames = [];
        let selectedIndex = -1;
        let isTypeaheadVisible = false;
        // Use existing isMobile variable or detect if not available
        const isMobileDevice = typeof isMobile !== 'undefined' ? isMobile : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Kiosk mode functionality
        let isKioskMode = false;

        function initializeKioskMode() {
            // Load kiosk mode setting from localStorage
            const savedKioskMode = localStorage.getItem('kiosk_mode');
            isKioskMode = savedKioskMode === 'true';
            
            // Update button UI
            updateKioskButton();
        }

        function toggleKioskMode() {
            isKioskMode = !isKioskMode;
            localStorage.setItem('kiosk_mode', isKioskMode.toString());
            
            // Clear saved username when entering kiosk mode
            if (isKioskMode) {
                localStorage.removeItem('booking_username');
                // Clear any existing input
                const usernameInput = document.getElementById('usernameInput');
                if (usernameInput) {
                    usernameInput.value = '';
                }
                // Hide clear button
                const clearButton = document.querySelector('.clear-saved-info');
                if (clearButton) {
                    clearButton.style.display = 'none';
                }
                // Show notification for kiosk mode ON
                showNotification('Kiosk mode enabled - Name memory disabled', 'info');
            } else {
                // Show notification for kiosk mode OFF
                showNotification('Kiosk mode disabled - Name memory enabled', 'success');
            }
            
            // Update button appearance
            updateKioskButton();
        }

        function updateKioskButton() {
            const kioskBtn = document.getElementById('kioskBtn');
            if (kioskBtn) {
                if (isKioskMode) {
                    kioskBtn.classList.add('kiosk-active');
                    kioskBtn.innerHTML = '<i class="fas fa-desktop"></i><span>Kiosk</span>';
                } else {
                    kioskBtn.classList.remove('kiosk-active');
                    kioskBtn.innerHTML = '<i class="fas fa-desktop"></i><span>Kiosk</span>';
                }
            }
        }

        // Load names from server
        async function loadNames() {
            try {
                const response = await fetch('/get_names');
                const data = await response.json();
                if (data.success) {
                    allNames = data.names;
                    debugLog(`Loaded ${allNames.length} names for type-ahead`);
                }
            } catch (error) {
                console.error('Error loading names:', error);
            }
        }

        // Filter names based on input
        function filterNames(query) {
            if (!query || query.length < 1) {
                return [];
            }
            const lowerQuery = query.toLowerCase();
            return allNames.filter(name => 
                name.toLowerCase().includes(lowerQuery)
            ).slice(0, 10); // Limit to 10 results
        }

        // Highlight matching text
        function highlightText(text, query) {
            if (!query) return text;
            const regex = new RegExp(`(${query})`, 'gi');
            return text.replace(regex, '<span class="highlight">$1</span>');
        }

        // Show typeahead dropdown
        function showTypeahead(names) {
            const dropdown = document.getElementById('typeaheadDropdown');
            if (!dropdown) return;

            if (names.length === 0) {
                hideTypeahead();
                return;
            }

            dropdown.innerHTML = '';
            
            // Add subtle scroll indicator for mobile if there are many results
            if (isMobileDevice && names.length > 5) {
                const scrollIndicator = document.createElement('div');
                scrollIndicator.style.cssText = 'padding: 6px 12px; font-size: 0.75rem; color: #999; text-align: center; background: #f8f9fa; border-bottom: 1px solid #e9ecef; position: sticky; top: 0; z-index: 1;';
                scrollIndicator.textContent = 'Scroll for more names';
                dropdown.appendChild(scrollIndicator);
            }
            
            names.forEach((name, index) => {
                const item = document.createElement('div');
                item.className = 'typeahead-item';
                item.innerHTML = highlightText(name, document.getElementById('usernameInput').value);
                
                // Track touch movement to distinguish between scroll and selection
                let touchStartY = 0;
                let touchMoved = false;
                let touchStartTime = 0;
                
                // Touch start - record initial position and time
                item.addEventListener('touchstart', (e) => {
                    touchStartY = e.touches[0].clientY;
                    touchMoved = false;
                    touchStartTime = Date.now();
                    // Don't prevent default here to allow scrolling
                });
                
                // Touch move - detect if user is scrolling
                item.addEventListener('touchmove', (e) => {
                    const touchY = e.touches[0].clientY;
                    const deltaY = Math.abs(touchY - touchStartY);
                    
                    // If moved more than 10px, consider it scrolling
                    if (deltaY > 10) {
                        touchMoved = true;
                        // Add visual feedback that we're in scroll mode
                        item.style.backgroundColor = '#f8fafc';
                        item.style.transition = 'background-color 0.1s ease';
                    }
                });
                
                // Touch end - only select if it wasn't a scroll
                item.addEventListener('touchend', (e) => {
                    const touchDuration = Date.now() - touchStartTime;
                    
                    // Reset visual feedback
                    item.style.backgroundColor = '';
                    item.style.transition = '';
                    
                    // Only select if:
                    // 1. Touch didn't move much (less than 10px)
                    // 2. Touch was quick (less than 300ms)
                    // 3. Touch didn't move at all
                    if (!touchMoved && touchDuration < 300) {
                        e.preventDefault();
                        e.stopPropagation();
                        selectName(name);
                    }
                });
                
                // Click event for desktop
                item.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    selectName(name);
                });
                
                // Prevent text selection on mobile
                item.addEventListener('selectstart', (e) => {
                    e.preventDefault();
                });
                
                dropdown.appendChild(item);
            });

            dropdown.style.display = 'block';
            isTypeaheadVisible = true;
            selectedIndex = -1;
            
            // Mobile-specific positioning
            if (isMobileDevice) {
                const input = document.getElementById('usernameInput');
                const inputRect = input.getBoundingClientRect();
                const viewportHeight = window.innerHeight;
                
                // Position dropdown below input with proper mobile positioning
                dropdown.style.position = 'fixed';
                dropdown.style.top = (inputRect.bottom + window.scrollY) + 'px';
                // Match input width exactly
                dropdown.style.left = inputRect.left + 'px';
                dropdown.style.right = 'auto';
                dropdown.style.width = inputRect.width + 'px';
                dropdown.style.maxWidth = inputRect.width + 'px';
                
                // Adjust max-height based on available space
                const availableHeight = viewportHeight - inputRect.bottom - 20;
                const maxHeight = Math.min(300, Math.max(100, availableHeight));
                dropdown.style.maxHeight = maxHeight + 'px';
                
                // Ensure it's above mobile keyboards
                dropdown.style.zIndex = '99999';
            }
            
            // Force reflow on mobile to ensure proper rendering
            if (isMobileDevice) {
                dropdown.offsetHeight;
            }
        }

        // Hide typeahead dropdown
        function hideTypeahead() {
            const dropdown = document.getElementById('typeaheadDropdown');
            if (dropdown) {
                dropdown.style.display = 'none';
            }
            isTypeaheadVisible = false;
            selectedIndex = -1;
        }

        // Select a name from dropdown
        function selectName(name) {
            const input = document.getElementById('usernameInput');
            if (input) {
                input.value = name;
                hideTypeahead();
                // Don't refocus on mobile as it can cause keyboard issues
                if (!isMobileDevice) {
                    input.focus();
                }
            }
        }

        // Handle keyboard navigation (desktop only)
        function handleTypeaheadKeydown(e) {
            if (!isTypeaheadVisible || isMobileDevice) return;

            const dropdown = document.getElementById('typeaheadDropdown');
            const items = dropdown.querySelectorAll('.typeahead-item');

            switch (e.key) {
                case 'ArrowDown':
                    e.preventDefault();
                    selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                    updateHighlight(items);
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    selectedIndex = Math.max(selectedIndex - 1, -1);
                    updateHighlight(items);
                    break;
                case 'Enter':
                    e.preventDefault();
                    if (selectedIndex >= 0 && items[selectedIndex]) {
                        selectName(items[selectedIndex].textContent);
                    }
                    break;
                case 'Escape':
                    hideTypeahead();
                    break;
            }
        }

        // Update highlighted item
        function updateHighlight(items) {
            items.forEach((item, index) => {
                item.classList.toggle('highlighted', index === selectedIndex);
            });
        }

        // Initialize type-ahead functionality
        function initializeTypeahead() {
            const usernameInput = document.getElementById('usernameInput');
            if (usernameInput) {
                // Ensure names are loaded
                if (allNames.length === 0) {
                    loadNames();
                }
                
                // Remove existing event listeners to avoid duplicates
                const newInput = usernameInput.cloneNode(true);
                usernameInput.parentNode.replaceChild(newInput, usernameInput);
                
                // Input event for type-ahead
                newInput.addEventListener('input', function(e) {
                    const query = e.target.value;
                    filteredNames = filterNames(query);
                    showTypeahead(filteredNames);
                });

                // Focus event - different behavior for mobile
                newInput.addEventListener('focus', function(e) {
                    const query = e.target.value;
                    if (query) {
                        filteredNames = filterNames(query);
                        showTypeahead(filteredNames);
                    }
                });

                // Blur event - longer delay for mobile to allow touch events
                newInput.addEventListener('blur', function() {
                    const delay = isMobileDevice ? 300 : 150;
                    setTimeout(hideTypeahead, delay);
                });

                // Keyboard navigation (desktop only)
                if (!isMobileDevice) {
                    newInput.addEventListener('keydown', handleTypeaheadKeydown);
                }
                
                // Enter key for booking confirmation
                newInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        confirmBooking();
                    }
                });
            }
        }

        // Listen for refresh messages from admin panel
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'REFRESH_TYPEAHEAD') {
                debugLog('Received refresh message from admin panel');
                loadNames();
            } else if (event.data && event.data.type === 'REFRESH_BAD_WORDS') {
                debugLog('Received bad words refresh message from admin panel');
                refreshBadWords();
            }
        });

        // Listen for BroadcastChannel messages (for same-origin communication)
        try {
            const channel = new BroadcastChannel('techcafe-refresh');
            channel.addEventListener('message', function(event) {
                if (event.data && event.data.type === 'REFRESH_TYPEAHEAD') {
                    debugLog('Received refresh message via BroadcastChannel');
                    loadNames();
                } else if (event.data && event.data.type === 'REFRESH_BAD_WORDS') {
                    debugLog('Received bad words refresh message via BroadcastChannel');
                    refreshBadWords();
                }
            });
        } catch (e) {
            debugLog('BroadcastChannel not supported');
        }


        function refreshBadWords() {
            // This function will be called when bad words are updated
            // For now, we'll just reload the page to get the updated bad words list
            debugLog('Refreshing bad words - reloading page');
            window.location.reload();
        }

        // Initialize type-ahead and kiosk mode when page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadNames();
            initializeTypeahead();
            initializeKioskMode();
        });


        // Hide typeahead when clicking/touching outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.typeahead-container')) {
                hideTypeahead();
            }
        });

        // Additional touch event handling for mobile
        if (isMobileDevice) {
            document.addEventListener('touchstart', function(e) {
                if (!e.target.closest('.typeahead-container')) {
                    hideTypeahead();
                }
            });
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', function() {
            stopAutoRefresh();
            stopTimeVisualization();
        });
    </script>
</body>
</html>
